# Kubernetes

- 컨테이너 기반 애플리케이션을 개발하고 배포할 수 있도록 만든 오케스트레이션 도구
- 쿠버네티스가 하는 것
	- 오브젝트 생성과 관리
	- Pod를 모니터링하고 재생성, 스케일링
	- 쿠버네티스에 제공된 리소스를 설정에 맞게 활용
	- 서비스 디스커버리와 로드 밸런싱
	- 스토리지 오케스트레이션
	- 자동화된 롤아웃, 롤백
	- 자동화된 빈 패킹
	- 자동화된 복구
	- 시크릿과 구성 관리
- 사용자가 하는 것
	- 클러스터와 노드 생성
	- 노드에 API 서버, kubelet, 그 외 다른 쿠버네티스 서비스와 소프트웨어 설치
	- 노드에 필요한 추가 리소스(로드 밸런서, 파일 시스템)를 생성

## 컴포넌트
### 컨트롤 플레인 컴포넌트

- 클러스터에 관한 전반적인 결정 (스케줄링 등)
- 클러스터 이벤트를 감지하고 반응
- 클러스터 내 어떤 머신에서도 동작 가능하지만 간결성을 위해 하나의 노드(마스터 노드)에 컨트롤 플레인 컴포넌트를 구동시키고 컨테이너는 다른 노드(워커 노드)에 구동

#### kube-apiserver
- 쿠버네티스 API를 노출하는 쿠버네티스 컨트롤 플레인 컴포넌트
- 수평으로 확장됨

#### etcd
- 모든 클러스터 데이터를 담는 쿠버네티스 뒷단 저장소
- 키-값 저장소
- 백업 필수

#### kube-scheduler
- 노드가 배정되지 않은 새로 생성된 파드를 감지하고 실행할 노드를 선택하는 컴포넌트

#### kube-controll-manager
- 컨트롤러 프로세스를 실행
	- 노드 컨트롤러: 노드가 다운되었을 때 통지와 대응
	- 잡 컨트롤러: 잡 오브젝트를 감시
	- 엔드포인트 슬라이스 컨트롤러: 서비스와 파드 사이의 연결
	- 서비스 어카운트 컨트롤러: 새로운 네임스페이스에 대한 기본 서비스 어카운트 생성

#### cloud-controller-manager
- 클라우드별 컨트롤 로직을 포함
- 클러스터를 클라우드 공급자의 API에 연결

### 노드 컴포넌트

- 동작 중인 파드를 유지
- 쿠버네티스 런타임 환경 제공
- 모든 노드 상에서 동작

#### kubelet
- 클러스터의 각 노드에서 실행되는 에이전트
- 각 파드에서 컨테이너가 확실히 동작하도록 관리
	- 쿠버네티스를 통해 생성되는 컨테이너만 관리

#### kube-proxy
- 클러스터 각 노드에서 실행되는 네트워크 프록시
- 노드의 네트워크 규칙을 유지 관리
- 클러스터 바깥에서 파드로 네트워크 통신을 할 수 있게 함

#### 컨테이너 런타임
- 컨테이너 실행 담당
- 모든 Kubernetes CRI 구현체 지원

### 애드온

- 쿠버네티스 리소스를 이용해 클러스터 구현

#### DNS
- 모든 쿠버네티스 클러스터는 클러스터 DNS를 갖춰야 함
- 구성환경 내 다른 DNS 서버와 더불어 쿠버네티스 서비스를 위해 DNS 레코드를 제공해주는 DNS 서버

#### 웹 UI 대시보드
- 클러스터와 클러스터에서 작동하는 애플리케이션에 대한 관리와 문제 해결 가능

#### 컨테이너 리소스 모니터링
- 중앙 디비 내의 컨테이너들에 대한 포괄적인 시계열 메트릭을 기록하고 이를 열람할 수 있음

#### 클러스터 레벨 로깅
- 로그 저장소에 컨테이너 로그를 저장

# Kubernetes Resources

- 쿠버네티스 오브젝트를 생성할 때 사용하는 틀

## 컨테이너 관련 리소스

- node
	- 컨테이너를 배치하는 서버
- namespace
	- 쿠버네티스 클러스터 안의 가상 클러스터
- pod
	- 컨테이너의 집합 중 가장 작은 단위
- replicaset
	- 같은 스펙을 갖는 파드를 여러 개 생성하고 관리
- deployment
	- rs의 리비전을 관리

## 네트워크 관련 리소스

- service
	- 파드를 외부 네트워크에 전달하기 위한 경로 정의
- ingress
	- 서비스를 쿠버네티스 클러스터 외부로 노출

## 정보 저장 관련 리소스

- secret
	- 인증 정보 저장
- configmap
	- 설정 정보 저장

## 데이터 저장관련 리소스

- persistent volume
	- 파드가 사용할 스토리지 크기 및 종류 정의
- persistent volume claim
	- 퍼시스턴트 볼륨을 동적으로 확보

## 배치 잡 관련 리소스

- job
	- 상주 실행을 목적으로 하지 않는 파드를 여러 개 생성하고 정상적인 종료 보장
- cron job
	- cron 문법으로 스케줄링되는 잡

# Kubernetes Objects
## Object 정의

- 지정된 상태가 유지되도록 쿠버네티스에 의해 제어됨
- spec, status라는 필드를 가짐
	- spec: 사용자가 기대하는 상태
	- status: spec에 대비한 현재 상태
- 메타데이터에 기술된 이름에 의해 식별됨

## 기본 Object

- 쿠버네티스에 의해 배포 관리되는 기본적인 오브젝트

### Pod

- 컨테이너의 가장 기본 단위
- 한 개 이상의 컨테이너로 구성된 컨테이너의 집합
- 특징
	- 파드마다 고유한 IP 주소
	- 같은 파드 내의 컨테이너는 IP와 포트를 공유
		- 파드에 속한 컨테이너는 로컬호스트로 서로 통신 가능
	- 파드 내의 컨테이너 간에는 디스크 볼륨 공유 가능

### Volume

- 영구적인 스토리지
- NFS, AWS EBS 등 다양한 유형의 볼륨 지원
- 볼륨이 Pod 내부 또는 외부에 존재 가능

### Service

- Pod가 생성될 때마다 새로운 IP가 부여되므로 클러스터 내외부 통신이 어려움
- 이를 위한 기능이 서비스
- 라벨링을 통해 같은 라벨을 가진 파드를 묶어 단일 엔드포인트 제공
- 고정적인 IP를 갖고 있으며 파드가 변경되어도 서비스의 IP는 변경되지 않음

### Namespace

- 클러스터 내의 리소스들을 논리적으로 구분할 수 있게하는 단위

## Controller
### Controller 정의

- 기본 오브젝트를 관리하며 추가적인 기능을 가진 오브젝트

### ReplicaSet

- 같은 스펙의 Pod를 묶어서 관리

### Deployment

- RS의 상위 개념으로 파드와 RS에 대한 배포 관리
	- 새 버전 배포 또는 부하 증가로 RS를 추가하는 등의 관리 가능
- 쉬운 롤백 가능
- 대부분 Deployment 단위로 파드 관리

### StatefulSet

- 파드의 상태를 유지하고 관리할 때 사용
	- 파드가 삭제되었다 다시 떠도 기존 상태 유지

### DaemonSet

- 전체 노드에서 항상 실행되어야하는 특정 파드를 실행할 때 사용
- 특정 노드에만 생성되도록 구성할 수 있음

### Job

- 하나 이상의 파드를 지정하고 지정된 수의 파드 실행
- 주로 백업이나 배치 작업같은 한번만 실행되고 종료되는 성격의 작업에 사용

### CronJob

- 잡을 주기적으로 실행

## Object 생성 방법

- 생성형
	- kubectl run, kubectl expose 등으로 개발 환경에서 빠르게 확인할 때 사용
- 명령형
	- kubectl create 등으로 오브젝트 버전 관리가 중요할 때 사용
- 선언형
	- kubectl apply 등으로 오브젝트 버전 관리가 중요할 때 사용

# Pods

- 컨테이너 애플리케이션의 기본 단우
- Pod 내부의 컨테이너는 리소스 공유 가능하고 로컬 호스트로 통신

## 특징

- 임시적이고 지속되지 않음
- 파드가 쿠버네티스에 관리되려면 컨트롤러 필요

## 생성 방법

- CLI
	- kubectl run
- YAML
	- kubectl apply

## Life Cycle

## Init Container

- 파드의 앱 컨테이너들이 실행되기 전에 실행되는 특수한 컨테이너
- 앱 이미지에는 없는 셋업을 위한 유틸리티 설정 또는 설정 스크립트 포함 가능

## Health Checks

- 애플리케이션이 정상적으로 기동되고 있는지 확인하는 기능 설정 가능
- 이상이 감지되면 컨테이너를 강제 종료하고 재시작 가능
- kubelet이 담당
	- Liveness Probe (활성 프로브)
		- 컨테이너의 앱이 정상적으로 실행되는지 검사
		- 실패하면 컨테이너 재시작
		- YAML(메니페스트 파일)에 명시
	- Readiness Probe (준비 상태 프로브)
		- 다른 애플리케이션의 요청을 받을 수 있는 지 검사
		- 실패하면 트래픽 전송 중지
	- 프로브 대응 행들러
		- exec
		- tcpSocket
		- httpGet

# ReplicaSet

- 일정 개수의 파드를 유지하는 컨트롤러
- 노드에 골고루 생성

## 작동 방식

- 정의 필드
	- 획득 가능한 파드를 식별하는 방법이 명시된 셀렉터
	- 유지해야하는 개수
	- 신규 파드에 대한 데이터를 명시하는 파드 템플릿

## 템플릿을 사용하지 않는 Pod의 획득

- 단독 파드를 생성하는 것은 문제가 없지만 단독 파드가 레플리카셋 셀렉터와 일치하는 레이블을 가지지 않도록 해야함
- 단독 파드가 RS의 셀렉터와 일치하는 레이블을 가지면 단독 파드가 RS에 속함

# Deployment

- 파드와 RS에 대한 선언적 업데이트 제공
- 의도하는 상태를 설명하고 컨트롤러가 현재 상태에서 의도하는 상태로 비율을 조정하며 변경

## 특징

- 원하는 목표 설정 -> 쿠버네티스가 이를 수행
- 일시 중지, 삭제, 롤백 가능
- 파드 스케일링 가능
	- 스케일링은 버전과는 상관 없음
- 자동 복구

## 배포 전략

### In-place Deployment (k8s: Recreate)

- 새로운 변경 사항이 포함된 애플리케이션만 반영
- 배포 그룹의 각 환경에 있는 애플리케이션을 중지한 후 최신 상태의 애플리케이션의 변경 사항이 설치되면 새 버전의 앱을 실행

### Rolling Update Deployment

- 한번에 정해진 수만큼의 서버에 새로운 변경 사항이 포함된 애플리케이션을 배포
- 구버전에서 새 버전으로 트래픽을 점진적으로 전환
- 서버 수의 제약이 있으면 유용하지만 배포 중에 인스턴스 수가 감소하므로 서버 처리량을 고려해야 함
- 람다나 ECS의 경우 롤링 배포가 기본적 배포 방식
- k8s에서
	- maxSurge, maxUnavilable을 동시에 0으로 설정 불가능

### Blue / Green Deployment

- 똑같은 배포 환경을 만들고 다른 한쪽에 새 버전을 올림
- 설치 후 LB의 라우팅을 새 버전 쪽으로 돌림
- 시스템 자원이 두배로 필요함
	- 클라우드에서는 큰 부담 요소가 아니므로 신경 안써도 됨

### Canary Deployment

- 가동 중인 서버의 일부에만 새로운 앱을 배포
- 점진적으로 새 버전 서버의 비율을 늘려가거나 다시 되돌릴 수 있음

# DaemonSet

-  각 노드에 파드를 하나씩 배치하는 리소스
- 레플리카 수를 지정할 수 없고 하나의 노드에 두 개의 파드를 배치할 수 없음
- 배치하고 싶지 않은 노드에는 따로 설정하면 됨
- 로그 수집, 리소스 사용 현황 모니터링 등에서 사용

## DaemonSet 업데이트 전략

- OnDelete
	- 메니페스트 파일이 변경되어도 기존 파드를 업데이트하지 않고 파드가 다시 생성될 때 새롭게 정의한 파드를 생성
- Rolling Update
	- 기본값이며 즉시 파드를 업데이트할 때 사용
	- maxSurge(동시에 생성할 수 있는 최대 파드 수) 설정 불가능!!
	- maxUnavailable(동시에 정지 가능한 최대 파드 수)만 설정 가능!!

# Service

- Pod를 외부에 연결하고 노출

## 기능

- 외부에 파드를 노출

## 서비스를 생성하는 방법

- 매니페스트 파일
- kubectl expose 명령

## Pod의 IP 주소를 기반으로 애플리케이션에 접근했을 때 문제점

- 파드가 죽었다 뜨면서 ip 주소가 변경될 수 있음
- 클라이언트가 하나의 아이피만 알고 접근하면 부하가 집중될 수 있음

## Types
### ClusterIP

- 디폴트 서비스
- 클러스터 내부에서 파드에 접근할 때 사용
- 외부로 파드를 노출하지 않기 때문에 클러스터 내부에서만 사용되는 파드에 적합
- 세션 어피니티 옵션
	- 클라이언트 IP 별로 전송 파드를 고정

### NodePort

- 파드에 접근할 수 있는 포트를 클러스터의 모든 노드에 동일하게 개방
- 외부에서 해당 아이피로 접근 가능
- 접근할 수 있는 포트는 랜덤으로 정해지지만 특정 포트로 접근하도록 설정 가능
- 노드의 공개 IP 주소에 공개 포트를 오픈

### LoadBalancer

- CSP에서 제공하는 로드 밸런서를 동적으로 프로비저닝해 파드에 연결
- 로드 밸런서에 들어오는 트래픽을 클러스터 내의 파드로 전달
- 클라우드 환경에서는 이걸 거의 씀

#### L4 LB
- 네트워크 계층 정보 기반 로드 밸런싱
- 아이피나 포트 정보 이용
- 쿠버네티스에서 말하는 로드 밸런서는 L4임

#### L7 LB
- 애플리케이션 계층 정보 기반 로드 밸런싱
- URL, HTTP Header, Cookie 등의 정보를 이용
- 쿠버네티스에서는 인그레스를 사용해 구현됨

#### 온프레미스에서 LB 서비스
- MetalLB라는 로드 밸런서를 붙여서 사용

### ExternalName

- 외부 서비스를 쿠버네티스 내부에서 호출하고자 할 때 사용
- 클러스터 내부 파드에서 외부 아이피 주소에 서비스 이름으로 접근 가능
- 파드에서 클러스터 외부의 엔드포인트에 접속하기 위한 이름을 해결해줌

# Ingress

- 클러스터 내의 서비스에 대한 외부 접근을 관리하는 API 오브젝트
- 일반적으로 HTTP를 관리
- 부하 분산, SSL 종료, 이름 기반의 가상 호스팅 제공
- 사용하려면 인그레스 컨트롤러 필요

## 개요


![](https://i.imgur.com/SAVKKeE.png)


### 주요 기능

- 외부 요청 라우팅
- 가상 호스트 기반의 요청 처리
- SSL TLS 보안 연결 처리

### 인그레스 컨트롤러

- 인그레스는 단지 요청을 처리하는 규칙을 정의하는 선언적 오브젝트
	- 외부 요청을 받아들일 실제 서버가 아님
- 인그레스를 생성하면 인그레스 컨트롤러라는 특수한 서버에 적용해야 규칙을 사용할 수 있음
- 실제로 외부 요청을 받아들이는 것은 인그레스 컨트롤러 서버이며 이 서버가 인그레스 규칙을 로드해서 사용

# Namespace

- 리소스를 논리적으로 구분하는 장벽
- 클러스터 안의 가상 클러스터
	- 파드, RS, Deployment, 서비스와 같은 리소스들이 묶여있는 가상 공간
- 네임스페이스마다 권한 설정 가능
- 네임스페이스는 개발 팀이 일정 규모 이상일 때 유용

## Namespace를 사용해 논리적으로 구분할 수 있는 대상

- kubectl 명령 적용 범위
- CPU 시간과 메모리 용량 등의 리소스 할당
- 파드 네트워크 통신의 접근 제어

## 기본 Namespace

### Default

- 기본 네임스페이스

### kube-node-lease

- 쿠버네티스 노드의 가용성을 체크하기 위한 네임스페이스
- 하트비트를 위한 leases 오브젝트가 있음

### kube-public

- 인증 받지 않은 사용자를 포함한 모든 사용자가 읽기 권한으로 접근 가능
- 사용 잘 안함

#### kube-system

- 클러스터의 리소스가 배치되는 네임스페이스
- 시스템이나 애드온이 사용

## Use Cases

- 하나의 클러스터에 다양한 환경(개발, 스테이징, 운영 등)을 구현할 때 사용

## 다른 Namespace에서의 접근

- 클러스터 내부에선 서비스 이름을 이용해 파드에 접근이 가능하지만 다른 네임스페이스면 불가능
- 서비스.네임스페이스.svc라는 이름으로 접근해야 함

# ConfigMap & Secret

- 설정값이나 인증 정보를 파드에 전달

## ConfigMap

- 일반 설정 정보를 저장
- 네임스페이스별로 존재
- 노출되어도 큰 문제가 없는 정보 저장

### 값을 생성, 조회, 사용하는 방법들

- kubectl create configmap
- 원시 형태, yaml 형태 조회
- 파드의 환경 변수로 사용
- 파드 내부의 파일로 마운트해서 사용
## Secret

- 인증 정보와 같이 보안이 필요한 정보, 민감한 정보를 저장하기 위해 사용
- 네임스페이스에 종속되는 쿠버네티스 오브젝트

### Secret을 생성, 사용하는 방법들

- --from-literal 옵션 이용해 생성
- --from-file 옵션 이용해 생성
- 파드의 환경 변수로 사용
- 파드 내부의 파일로 마운트해서 사용

# Job

- 일회성 또는 배치 작업을 실행하기 위한 객체
- 주로 한번 실행하고 완료해야 하는 작업을 정의하는 데 사용
- 파드의 모든 컨테이너가 정상적으로 종료될 때까지 재실행

## Job Controller의 특징

- 지정한 실행 회수와 병행 개수에 따라 한 개 이상의 파드 실행
- 파드 내의 모든 컨테이너가 정상 종료되어야 파드가 정상 종료된 것으로 취급
- 파드의 실행 횟수를 전부 정상 종료하면 잡이 종료됨
- 노드 장애 등에 의해 파드가 제거되면 다른 노드에서 파드 실행
- 잡을 삭제하면 관련된 파드가 모두 삭제됨

## Use Cases

- 온라인 배치 처리 요청

## Job의 병렬성 관리

- 잡 하나가 동시에 실행할 파드 지정
- 매니페스트 파일의 spec.parallelism 필드에 설정
- 기본값 1, 0으로 설정하면 잡 정지

## 메시지 브로커와 잡 컨트롤러의 결합

![](https://i.imgur.com/kUlBq9f.png)

# CronJob

- 크론 형식 시간을 지정해 잡을 시간 기준으로 관리
- 지정 시간에 한 번만 잡을 실행하거나 주기적으로 반복 실행
- 주로 애플리케이션 프로그램 데이터, 데이터베이스 백업 등에 사용

## CronJob과 Job의 관계

![](https://i.imgur.com/ihoHRwA.png)

## CronJob 설정

### spec.schedule

- **Cron 형식으로 스케줄을 기술**
- 분 (0-59), 시 (0-23), 일 (1-31), 월 (1-12), 요일 (0-7, 0: 일요일, 7: 일요일)

### spec.startingDeadlineSeconds

- 지정된 시간에 CronJob이 실행되지 못했을 때 필드 값으로 설정한 시간까지 지나면 CronJob이 실행되지 않게 함

### spec.concurrentPolicy

- CronJob이 실행하는 Job의 동시성을 관리
- 병렬성과는 개념이 조금 다름
    - 앞에 실행한 Job이 끝나지 않더라도 시간이 되면 새로운 Job을 띄울 것인지를 관리
- Allow
    - 기본값, 여러 개의 Job을 동시에 실행할 수 있게 함
- Fobid
    - 동시 실행을 금지
- Replace
    - 앞에 실행했던 Job이 실행 중인 상태에서 새로운 Job을 실행할 시간이 되면 이전에 실행 중이던 Job을 새로운 Job으로 대체

### spec.successfulJobHistoryLimit

- 정상 종료된 Job 내역의 보관 개수
    - 기본값: 3

### spec.failedJobHistoryLimit

- 비정상 종료된 Job 내역의 보관 개수

# Storage

- Stateless Applications
	- 디플로이먼트의 각 파드는 별도의 데이터를 가지고 있지 않으며 단순히 요청에 대한 응답만 반환
	- 요청이 다음 요청에 영향을 미치지 않음
- Stateful Application
	- 파드 내부에 특정 데이터를 보유해야 하는 애플리케이션

## K8s Volumes
### 볼륨 종류와 액세스 가능 범위

![](https://github.com/seungwonbased/TIL/blob/main/K8s/assets/store1.png)

## Local Volumes
### emptyDir

- 같은 파드 내의 컨테이너 간 데이터 공유

### hostPath

- 워커 노드 내의 디렉터리를 볼륨으로 사용해 파드 간 데이터 공유
- 파드가 다른 노드에 생성되면 이전에 생성한 데이터를 참조할 수 없음
- 파드가 삭제되어도 노드의 디렉터리에는 데이터가 유지됨
- 노드가 꺼지면 마운트된 데이터도 사라짐
- 보안 위험이 있어 가능하면 사용 X

## Persistent Volumes
### NFS

- 네트워크 파일 공유 프로토콜
- 여러 컴퓨터 간에 파일 및 디렉터리 공유, 액세스
- nfs-common
	- NFS 클라이언트를 지원하는 리눅스 패키지
	- NFS 서버로부터 파일 및 디렉터리를 마운트하고 읽고 쓸 수 있도록 설정
### PV & PVC

![](https://i.imgur.com/maBdHZg.png)

- 볼륨과 애플리케이션의 분리의 어려움이 있어 생김
- PV, PVC를 통해 파드가 볼륨의 세부적인 사항을 몰라도 볼륨을 사용할 수 있도록 추상화
- PV
	- 볼륨 그 자체
	- 클러스터 안에서 자원으로 다룸
	- 파드와 별개로 관리되며 별도의 생명 주기가 있음
- PVC
	- 사용자가 PV에 하는 요청
	- 사용하고 싶은 용량은 얼마인지, 읽기 쓰기는 어떤 모드로 하고 싶은지
- 쿠버네티스 볼륨을 파드에 직접 할당하는 방식이 아니라 중간에 PVC를 둬 파드가 사용할 스토리지를 분리
	- 파드가 어떤 스토리지를 사용하는 지 신경 안써도 됨

#### PV PVC 생명주기

![](https://i.imgur.com/IS3EQ5F.png)

- 1. 프로비저닝
	- PV를 만드는 단계
	- static
		- pv를 미리 만들어두고 사용하는 방법
		- 사용할 수 있는 스토리지 용량이 제한적일 때 유용
	- dynamic
		- 요청이 있을 때마다 PV를 만드는 방법
		- 사용자가 원하는 용량만큼 생성해서 사용 가능
- 2. 바인딩
	- 프로비저닝으로 만든 PV와 PVC를 연결하는 단계
	- 매핑은 1:1 관계로 PVC 하나가 여러 개 PV에 할당될 수 없음
- 3. 유징
	- PVC가 파드에 설정되고 파드는 PVC를 볼륨으로 인식해서 사용
	- 할당된 PVC는 파드를 유지하는 동안 계속 사용하면 시스템에서 임의로 삭제 불가
- 4. 리클레이밍
	- 사용이 끝난 PVC는 삭제되고 PVC를 사용하던 PV를 초기화하는 과정
	- 리클레이밍 정책
		- Retain
			- PVC가 삭제되어도 저장소에 있는 파일을 삭제하지 않는 정책
				- PV는 수동으로 삭제해야 함
			- 볼륨이 릴리즈 되어서 다시 바인딩할 수 없어도 새로 볼륨을 만들고 경로를 똑같이 하면 그대로 데이터를 다시 쓸 수 있음
		- Delete
			- PVC가 삭제되면 PV와 연결된 저장소 자체를 삭제
			- NFS와 같은 스토리지 타입에서는 딜리트가 제대로 적용되지 않음
			- CSP가 제공하는 서비스에서는 동적으로 스토리지를 프로비저닝하기 때문에 딜리트 정책 사용 불가
		- Recycle
			- PVC가 삭제되면 PV와 연결된 저장소 데이터는 삭제하지만 저장소 볼륨 자체는 삭제하지 않고 유지
- PV Access Modes
	- RWO (ReadWriteOnce)
		- 하나의 노드에서 해당 볼륨이 읽기-쓰기로 마운트됨
	- ROX (ReadOnlyMany)
		- 볼륨이 많은 노드에서 읽기 전용으로 마운트됨
	- RWX (ReadWriteMany)
		- 볼륨이 많은 노드에서 읽기-쓰기로 마운트됨
	- RWOP (ReadWriteOncePod)
		- 볼륨이 단일 파드에 읽기-쓰기로 마운트됨
- PV Status
	- Available
		- 아직 클레임에 바인딩되지 않은 사용 가능한 리소스
	- Bound
		- 볼륨이 클레임에 바인딩됨
	- Released
		- 클레임이 삭제되었지만 클러스터에서 아직 리소스를 반환하지 않음
		- 이 경우 PV는 어떤 PVC에도 더이상 바운드되지 않고 사용되지 않는 상태
	- Failed
		- 볼륨 자동 반환에 실패

# StatefulSet

- 애플리케이션의 스테이트를 관리하는 데 사용
- 파드 집합의 디플로이먼트와 스케일링을 관리하고 파드들의 순서 및 고유성을 보장
- PV와 파드를 함께 조합해서 제어
- 디플로이먼트와 다르게 스테이트풀셋은 각 파드의 독자성을 유지
	- 파드들은 동일한 스펙으로 생성되지만 서로 교체는 불가능

## Deployment vs StatefulSet

![](https://i.imgur.com/366MrwV.png)

- Headless 서비스
	- 다른 서비스 유형과 달리 Cluster IP를 생성하지 않고 각 파드에 고유한 DNS 이름을 부여해 네트워크 통신을 지원
	- 주로 내부 네트워크 통신 및 서비스 디스커버리를 위한 목적으로 사용되며 외부로 노출되지 않는 경우가 많음

![](https://i.imgur.com/VVtEqzZ.png)

![](https://i.imgur.com/iWhHfSh.png)

- 디플로이먼트
	- 노드가 응답을 하지 않으면 다른 노드에 파드를 대체 가동
- 스테이트풀셋
	- 노드가 응답을 하지 않아도 노드가 확실히 죽거나 클러스터에서 삭제된 게 아니라면 대체 파드를 가동 안함