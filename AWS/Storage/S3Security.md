# Amazon S3 Security
## Amazon S3 - Object Encryption

- 다음의 다섯 가지 방법을 이용해서 S3 버킷에 있는 객체들을 암호화할 수 있음
-  서버 측 암호화 (Server-Side Encryption)
	1. SSE-S3
		- Amazon S3에서 관리하는 키를 이용한 서버 측 암호화
		- 버킷과 객체에 대해 기본값으로서 활성화되어 있음
	2. SEE-KMS
		- KMS 키를 이용해서 암호화 키를 관리
	3. SEE-C
		- 다음은 고객이 제공한 키를 사용
		- 이 경우에는 사용자가 가진 키를 제공
4. 클라이언트 측 암호화
	- 이 경우에는 클라이언트 측의 모든 걸 암호화한 다음에 그걸 Amazon S3에 업로드
	- 어떤 상황에 어떤 걸 사용하는지 알아야 함
5. DSSE-KMS
		- KMS를 기반으로 한 이중 암호화

### S3 Encryption - SSE-S3

![se1](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/se1.png)

- Amazon S3의 SSE-S3 암호화는 AWS가 처리하고 관리하고 소유한 키를 이용해서 암호화
- 사용자는 그 키에 절대로 액세스할 수 없음
- 객체는 AWS에 의해 서버 측에서 암호화가 됨
- 암호화의 보안 유형은 AES-256
- 사용자는 Amazon S3가 SSE-S3 메커니즘을 이용해서 객체를 암호화하도록 요청하기 위해 헤더를 "x-amz-server-side-encryption":"AES256"이라고 설정해야 함
- 그리고 SSE-S3는 새로운 버킷과 새로운 객체에 대해 기본값으로서 활성화되어 있음
- 작동 방식 예시
	- Amazon S3가 있고 사용자가 있음
	- 사용자는 올바른 헤더를 써서 파일을 업로드, 그리고 그게 Amazon S3 아래의 객체가 될 것
	- 그럼 Amazon S3는 S3가 보유한 키와 그 객체를 짝지어줌
	- 그런 다음에 사용자는 그 키와 객체를 혼합해서 암호화
	- 그게 사용자의 S3 버킷에 저장됨

### S3 Encryption - SSE-KMS

![se2](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/se2.png)

- SSE-KMS는 AWS와 S3 서비스가 보유한 키에 의존하지 않고 KMS 서비스, 즉 키 관리 서비스를 이용해서 직접 자신의 키를 관리
- KMS를 사용할 경우에는 사용자가 키를 통제할 수 있다는 장점
	- 사용자는 KMS에서 직접 키를 생성할 수 있음
- CloudTrail을 이용해서 키 사용을 검사할 수 있음
	- 그래서 누군가가 KMS에서 키를 사용할 때마다 AWS 안에서 일어나는 모든 걸 로깅하는 서비스인 CloudTrail에 로깅됨
- 반드시 "x-amz-server-side-encryption":"aws:kms"라는 헤더가 있어야 함
	- 그러면 객체가 서버 측에서 암호화됨
- 작동 방식 예시
	- 사용자가 객체를 업로드
		- 이번엔 다른 헤더를 사용
		- 그리고 헤더 안에서 사용자가 사용하려는 KMS 키를 지정
	- 그러면 객체가 Amazon S3에 나타남
	- 그리고 사용될 KMS 키가 AWS 외부에서 오게 됨
	- 이 두 개가 혼합되고 암호화가 이루어짐
	- 파일이 결국 S3 버킷으로 감
	- 그럼 이제 S3 버킷에서 그 파일을 읽기 위해서는 사용자는 객체 자체에 액세스할 수 있어야 할 뿐만 아니라 이 객체를 암호화하는 데 사용된 KMS 키에도 액세스할 수 있어야 함
		- 보안 수준이 한층 강화됨

#### SSE-KMS의 약간의 제한 사항
- 사용자는 Amazon S3로 업로드하고 거기서 다운로드하기 때문에 KMS 키를 사용해야 함
	- KMS 키에는 예를 들어 GenerateDataKey 같은 자체 API가 있음
	- 사용자는 Decrypt API를 사용해서 복호화
 - 사용자는 KMS 서비스에 API 호출
	- 그리고 그 API 호출 건은 모두 KMS의 초당 API 호출 쿼터에 합산됨
	- 리전에 따라 초당 5,000 내지 30,000 건의 요청이 가능할 것
- 만일 사용자의 S3 버킷의 처리량이 아주 많고 모든 게 KMS 키로 암호화되어 있다면 스로틀링 사례가 될 수 있음

### S3 Encryption - SSE-C

![se3](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/se3.png)

- SSE-C형 암호화는 키가 AWS 외부에서 관리되지만 여전히 서버 측 암호화
	- 왜냐면 사용자가 키를 AWS로 전송하기 때문
- Amazon S3는 사용자가 제공한 암호화 키를 절대 저장하지 않을 것임
	- 사용 후에는 폐기됨
- 사용자는 키를 Amazon S3로 전송하기 때문에 반드시 HTTPS를 사용해야 함
	- 모든 요청에 HTTP 헤더의 일부로서 키를 전달해야 함
- 작동 방식 예시
	- 사용자는 파일과 키를 업로드, 사용자가 AWS 외부에서 그 키를 관리
	- 그러면 Amazon S3는 클라이언트가 제공한 키와 객체를 사용해서 약간의 암호화를 수행하고 암호화된 파일을 S3 버킷에 넣음
	- 물론 사용자가 그 파일을 읽으려면 역시 파일을 암호화하기 위해 사용한 키를 제공해야 함

### S3 Encryption - Client-Side Encryption

![se4](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/se4.png)

- 클라이언트 측 암호화는 클라이언트 측 암호화 라이브러리 같은 클라이언트 라이브러리를 활용하면 더 쉽게 구현할 수 있음
- 클라이언트 측 암호화는 클라이언트가 직접 데이터를 암호화한 다음에 Amazon S3에 전송한다는 개념
- 그리고 물론 Amazon S3로부터 데이터를 받을 수 있음
- 데이터의 복호화는 Amazon S3 외부의 클라이언트 측에서 이루어짐
	- 클라이언트가 키와 암호화 사이클을 완전하게 관리하는 것
- 작동 방식 예시
	- 파일이 있고, AWS 외부에 클라이언트 키가 있음
	- 클라이언트가 직접 암호화를 제공하고 수행
	- 암호화된 파일이 만들어지고, 업로드하기 위해 그 파일을 그대로 Amazon S3에 전송할 수 있음

## Amazon S3 - Encryption in Transit (SSL / TLS)

- 전송 중 암호화에는 통신 중 암호화는 SSL 또는 TLS라고도 부름
- Amazon S3 버킷에는 기본적으로 2개의 엔드포인트가 있음
	- 암호화가 되지 않는 HTTP 엔드포인트
	- 전송 중 암호화가 제공되는 HTTPS 엔드포인트
- Amazon S3를 사용할 때는 데이터 송신 보안을 위해 HTTPS를 사용하도록 100% 권고
- SSE-C 타입의 메커니즘을 이용한다면 반드시 HTTPS 프로토콜을 사용해야 함
- 실생활에선 모든 클라이언트가 기본값으로서 HTTPS 엔드포인트를 사용

### Amazon S3 – Force Encryption in Transit (aws:SecureTransport)

![se5](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/se5.png)

- 어떻게 전송 중 암호화를 강제할 수 있는지?
- 버킷 정책을 사용하면 됨
- S3 버킷에 버킷 정책을 첨부하고 다음과 같은 구문을 첨부
	- aws:SecureTransport가 false라면 GetObject 작업을 거부하라고 하는 것
	- 그럼 HTTPS를 사용할 경우에는 언제나 SecureTransport는 true일 거고, 암호화 연결을 사용하고 있지 않다면 false일 것임
		- 그래서 버킷에 HTTP를 사용하려는 모든 사용자가 차단될 것
		- HTTPS를 사용하는 사용자는 허용될 수 있음

## Amazon S3 - Default Encryption vs Bucket Policies

![se6](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/se6.png)

-  기본값 암호화와 버킷 정책을 비교
- 기본값으로서 지금 모든 버킷은 SSE-S3 암호화가 되어 있음
	- 즉 버킷에 저장된 새로운 객체에 SSE-S3 암호화가 자동으로 적용됨
	- 하지만 SSE-KMS 같은 다른 기본 암호화로 변경할 수 있음
- 그렇지만 또 버킷 정책을 이용해서 암호화를 강제하고 올바른 암호화 헤더가 없는 경우에는 S3 객체를 PUT하는 API 호출을 거절할 수 있음
	- 예를 들어 SSE-KMS나 SSE-C에 대해 적용할 수 있음
- 예시
	- 왼쪽 예시와 같은 경우에는 PutObject를 하려고 하는데 aws:kms라는 암호화 헤더가 없으면 그 요청을 거부하라고 하고 있음
	- 또 오른쪽에서는 이걸 업로드하고 있는데 고객 측 알고리즘, 즉 SSE-C가 없으면 그 객체를 거부하라고 하고 있음
- 버킷 정책으로도 버킷 안의 암호화를 강제할 수 있다는 걸 알 수 있음
- 버킷 정책은 항상 여러분의 기본값 암호화 설정 이전에 평가될 것임
- 정리하자면 기본값 암호화는 기본값으로서 SSE-S3로 제공되는데 사용자는 그걸 변경할 수 있고, 버킷 정책을 선제적으로 적용해서 원하는 암호화를 강제할 수 있다는 점만 기억하면 됨

## S3 CORS

- CORS: Cross-Origin Resource Sharing (교차 오리진 리소스 공유)
- 시험에 나올 CORS 관련 질문은 하나
	- 작동 원리
- 오리진: 체계(Protocol)와 호스트(Domain)와 포트로 구성됨
- 예시: https://www.example.com
	- HTTPS의 포트는 443
	- 프로토콜은 HTTP
	- 도메인은 www.example.com
- CORS는 웹 브라우저 기반 보안 메커니즘으로 메인 오리진을 방문하는 동안 다른 오리진에 대한 요청을 허용하거나 거부
	- 체계, 호스트, 포트가 동일할 때 오리진이 같다고 함
- 같은 오리진 예시
	- http://example.com/app1 & http://example.com/app2
- 다른 오리진 예시
	- www.example.com & other.example.com
- 웹 브라우저가 한 웹사이트를 방문하는 동안 요청 체계의 일부로 다른 웹사이트에 요청을 보내야 할 때 다른 오리진이 **CORS 헤더**를 사용해서 요청을 허용하지 않는 한 해당 요청은 이행되지 않음
	- 이를 '액세스 제어 허용 오리진' 헤더 라고 함

![se7](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/se7.png)

- 도식을 통한 작동 방식과 활용 방법 예시
- 오리진인 웹 서버가 있음
	- https://www.example.com
 - 웹 브라우저가 있음
 - 교차 오리진인 두 번째 웹 서버가 있음
	- https://www.other.com
- 웹 브라우저가 첫 번째 오리진 웹 서버에 HTTPS 요청
- 결과의 일부로 검색된 index.html 파일이 가령 다른 웹 서버에서 이미지도 가져와야 한다고 말함
- 웹 브라우저에는 보안 기능이 내장되어 있어 먼저 교차 오리진에 사전 요청을 보냄
- www.other.com에 대한 옵션이 필요하고 해당 요청의 오리진이 https://www.example.com 라는 걸 알려줌
- 웹 서버가 교차 오리진 리소스 공유를 사용하도록 구성되었다면 www.example.com 오리진을 허용하고 GET, PUT, DELETE 메서드를 허용할 것
- 이것이 CORS 헤더
	- 웹 브라우저가 이 CORS 헤더에 만족한다면 웹 브라우저는 다른 서버에 이 파일을 검색하고 호출하도록 요청

### Amazon S3 - CORS

![se8](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/se8.png)

- 시험에 자주 나오는 문제
- Amazon S3에 CORS가 적용되는 방식
- 클라이언트가 S3 버킷에서 교차 오리진 요청을 하면 정확한 CORS 헤더를 활성화해야 함
- 이 작업을 빠르게 수행하려면 특정 오리진을 허용하거나 \*(별표)를 붙여 모든 오리진을 허용
- 예시
	- 웹 브라우저와 정적 웹사이트가 활성화된 S3 버킷이 있음
		- my-bucket-html
	- 에셋과 이미지는 다른 S3 버킷인 my-bucket-assets에 저장
		- 여기서도 정적 웹사이트를 활성화함
	- 웹 브라우저는 첫 번째 S3 버킷으로 가서 해당 웹사이트 URL에 대한 index.html 파일을 요청
		- 정적 웹사이트 URL
	- 반환된 index.html에는 이미지가 들어 있음
		- 해당 이미지는 다른 웹사이트에 존재
	- images/coffee.jpg 파일을 요청
		- 웹 브라우저가 보내는 것
		- 이번에는 다른 웹사이트가 대상 호스트이고 첫 번째 웹사이트가 오리진
		- S3 버킷이 정확한 CORS 헤더를 갖도록 구성되지 않았다면 요청을 거부
		- 요청을 허용한 경우라면 정확한 헤더를 갖고 요청이 처리되어 이미지를 얻을 수 있음
- CORS는 웹 브라우저 보안 메커니즘으로 다른 오리진에서 한 S3 버킷에 들어 있는 검색된 이미지, 자산, 파일을 요청할 수 있게 해줌

## Amazon S3 - MFA Delete

- MFA Delete 보안 기능
- MFA는 멀티 팩터 인증을 의미
	- 사용자가 장치에서 코드를 생성하도록 강제
	- Google Authenticator 애플리케이션이 설치된 휴대폰이나 MFA 하드웨어 장치에서 생성
- MFA는 코드를 생성하는데 중요한 작업을 수행하기 전에 Amazon S3에 해당 코드를 삽입해야 함
- **MFA가 필요한 상황**
	- 객체 버전을 영구적으로 삭제할 때
		- 영구 삭제에 대한 보호 설정
	- 버킷에서 버저닝을 중단할 때
	- 이 두 가지 옵션은 파괴적이라 MFA가 필요
- MFA가 필요하지 않은 상황
	- 버저닝을 활성화할 때
	- 삭제된 버전을 나열할 때
	- 위험한 작업이 아니기 때문에 MFA가 굳이 필요하지 않음
- MFA Delete를 사용하려면 먼저 버킷에서 버저닝을 활성화해야 함
	- 버저닝과 관련되어 있기 때문
- 버킷 소유자, 즉 **루트 계정**만이 MFA Delete를 활성화하거나 비활성화할 수 있음
- MFA Delete는 추가 보호 기능이며 특정 객체 버전의 영구 삭제를 방지하는 역할을 한다는 점만 기억

## Amazon S3 - Access Logs

- S3 액세스 로그는 감사 목적으로 S3 버킷에 대한 모든 액세스를 기록할 수 있음
- 어떤 계정에서든 S3로 보낸 모든 요청은 승인 또는 거부 여부와 상관없이 다른 S3 버킷에 파일로 기록됨
	- 해당 데이터는 Amazon Athena 같은 데이터 분석 도구로 분석할 수 있음
- 대상 로깅 버킷은 같은 AWS 리전에 있어야 함
- 작동 방식
	- S3 버킷에 요청할 경우 액세스 로그를 활성화해서 모든 요청이 로깅 버킷에 기록되도록 설정하면 됨
- 특정 로그 형식
	- https://docs.aws.amazon.com/AmazonS3/latest/dev/LogFormat.html
	- 위 URL에서 로그 형식을 확인할 수 있음
- 액세스 로그의 주의 사항
	- 절대로 로깅 버킷을 모니터링하는 버킷과 동일하게 설정하면 안 됨
		- 동일하게 설정하면 로깅 루프가 생성되고 무한 반복되어 버킷의 크기가 기하급수적으로 증가하게 됨
		- 객체를 넣었는데 앱 버킷과 로깅 버킷이 동일하면 로킹 루프가 생겨 로그를 반복적으로 기록하게 됨

## Amazon S3 - Pre-Signed URLs

- Amazon S3의 '미리 서명된 URL'은 S3 콘솔, CLI, SDK를 사용하여 생성할 수 있는 URL
- URL에는 만료 기한이 있음
	- S3 콘솔을 사용하면 최대 12시간이고 AWS CLI를 사용하면 168시간까지 사용할 수 있음
- 미리 서명된 URL을 생성할 때 URL을 받는 사용자는 URL을 생성한 사용자의 GET 또는 PUT에 대한 권한을 상속
- 사용 사례 예시
	- 프라이빗 S3 버킷이 있다고 가정
	- AWS 외부의 사용자에게 한 파일에 대한 액세스 권한을 부여해야 할 때 퍼블릭 파일로 설정하고 싶지 않음
	- 해당 파일을 가지고 미리 서명된 URL을 생성
	- 그러면 S3 버킷이 URL을 제공하고 해당 URL은 미리 서명됨
	- URL이 자격 증명을 이어받아 해당 파일에 액세스할 수 있는 권한을 부여
	- 그런 다음 이 URL을 제한된 시간 내에 파일에 대한 액세스 권한을 부여할 대상 사용자에게 보내면 사용자는 URL을 사용해서 S3 버킷의 파일에 액세스
	- 만료 기간 후에는 S3 버킷에서 파일을 다시 가져옴
- 미리 서명된 URL은 다운로드 또는 업로드를 위해 특정 파일에 임시로 액세스할 때 아주 널리 사용되는 방법
- 가령 로그인한 사용자만 S3 버킷에서 프리미엄 비디오를 다운로드할 수 있도록 허용하거나 사용자 목록이 계속 변하는 경우 URL을 동적으로 생성해서 파일을 다운로드할 수 있게 하는 것
- 또는 일시적으로 사용자가 S3 버킷의 특정한 위치에 파일을 업로드하도록 버킷을 비공개로 유지하면서 허용할 수 있음

## AWS Glacier Vault Lock

- S3 Glacier 볼트 잠금은 WORM 모델을 채용하기 위해 Glacier 볼트를 잠그는 것
	- WORM: Write Once Read Many model (한 번 쓰고 여러 번 읽는다)
- 객체를 가져와서 S3 Glacier 볼트에 넣은 다음 수정하거나 삭제할 수 없도록 잠그는 것
- 작동 방식
	- 먼저 Glacier 위에 볼트 잠금 정책을 생성한 다음 향후 편집을 위해 정책을 잠금
	- 일단 볼트 잠금 정책을 설정하고 잠근 후에는 누구도 변경하거나 삭제할 수 없게 됨
		- 규정 준수와 데이터 보존에 아주 유용
		- 일단 객체가 Glacier 볼트에 삽입되면 볼트에 볼트 잠금 정책이 적용되어 있으므로 객체를 절대 삭제할 수 없음
		- 관리자나 AWS 서비스를 사용해도 삭제할 수 없음

### S3 Object Lock

- 이와 유사한 S3 옵션이 있는데, 조금 더 복잡
- **S3 객체 잠금을 활성화하려면 먼저 버저닝을 활성화해야 함**
- 여기서도 WORM 모델을 채택할 수 있음
- 객체 잠금은 전체 S3 버킷 수준의 잠금 정책이 아니라 버킷 내의 모든 객체에 **각각** 적용할 수 있는 잠금
	- 단일 객체를 객체 잠금 할 수 있음
- S3 객체 잠금을 사용하면 특정 객체 버전이 특정 시간 동안 삭제되는 걸 차단할 수 있음
- 두 가지 보존 모드 (Rentention mode)
	1. 규정 준수 모드 (Compliance)
		- 규정 준수 모드는 S3 Glacier 볼트 잠금과 매우 유사
		- 사용자를 포함한 그 누구도 객체 버전을 덮어쓰거나 삭제할 수 없음
		- 규정 준수 모드에서는 누구도 객체를 변경할 수 없음
		- 보존 모드 자체도 변경할 수 없음
		- 보존 기간도 단축할 수 없음
		- 따라서 규정 준수를 엄격히 적용할 때 사용
	2. 거버넌스 보존 모드 (Governance)
		- 조금 더 유연성이 필요할 땐 거버넌스 보존 모드를 사용
		- 이 경우 대부분의 사용자는 객체 버전을 덮어쓰거나 삭제하거나 로그 설정을 변경할 수 없음
		- 하지만 관리자 같은 일부 사용자는 IAM을 통해 부여받은 특별 권한으로 보존 기간을 변경하거나 객체를 바로 삭제할 수 있음
		- 규정 준수 보존 모드는 매우 엄격한 반면 거버넌스 보존 모드는 좀 더 유연성이 있어 일부 사용자가 관리자 권한을 갖고 객체를 변경할 수 있음
	- 두 가지 모드 모두 보존 기간을 설정해야 함
		- 보존 기간을 설정해 규정 준수 또는 거버넌스 모드를 적용하면 고정된 기간 동안 객체를 보호할 수 있고 원하는 만큼 기간을 연장할 수 있음
- S3 객체 잠금으로 할 수 있는 일이 하나 더 있음
	- 객체에 '법적 보존 (Legal Hold)' 상태를 설정하는 것
	- 법적 보존을 설정하면 S3 버킷 내 모든 객체를 무기한으로 보호
	- 보존 기간과는 무관하기 때문에 아주 중요한 객체에 법적 보존을 설정함
	- 대개 재판에서 사용될 수 있는 중요한 객체에 법적 보존을 설정
	- 법적 보존을 설정하면 보존 모드나 보존 기간에 상관없이 객체가 영구적으로 보호됨
	- s3:PutObjectLegalHold IAM 권한을 가진 사용자는 어떤 객체에든 법적 보존을 설정하거나 제거할 수 있음
	- 이건 유연한 모드임
		- 객체를 보호하고 싶을 때 관리자는 PutObjectLegalHold 권한을 사용
		- 예를 들어 법적 조사가 끝난 다음에 PutObjectLegalHold IAM 권한으로 법적 보존을 제거

## Amazon S3 - Access Points

![se9](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/se9.png)

- S3 액세스 포인트
- 예시
	- 많은 데이터가 담긴 S3 버킷을 가정
	- 재무 데이터나 영업 데이터 등등이 있고, 다양한 사용자나 그룹들이 데이터에 액세스하려고 함
	- 아주 복잡한 S3 버킷 정책을 생성하고 시간이 지나면서 그게 커지도록 할 수 있는데, 사용자와 데이터가 많아질수록 이걸 관리하기가 더욱 어려워질 수 있음
	- 해법으로 S3 액세스 포인트라는 걸 만들 수 있음
	- 예를 들면 Finance 액세스 포인트를 만들 수 있고, 그건 재무 데이터와 연결될 것임
		- 재무 데이터에는 액세스 포인트 정책을 정의해 접근
			- 그 정책은 S3 버킷 정책과 똑같은 모습일 것
			- /finance라는 접두어에 읽기와 쓰기 액세스 권한을 부여
	- Sales 액세스 포인트를 정의할 수 있음
		- 영업 데이터에 액세스 포인트 정책을 정의해 접근
			- 액세스 포인트 정책 덕분에 영업 데이터와 연결될 것
			- /sales라는 접두어에 읽기와 쓰기 액세스 권한을 부여
	- Analytics 액세스 포인트를 만들어 재무와 영업 데이터를 지시하도록 할 수 있음
		- 하지만 읽기 전용 액세스 권한만 부여할 것
		- Analytics 액세스 포인트에 대한 읽기 전용 정책을 생성
	- 모든 액세스 포인트는 각자 보안을 갖고 있음
	- 적절한 IAM 권한이 있다면 사용자들은 Finance 액세스 포인트에 액세스할 수 있음
		- 버킷의 재무 부분에만 접속할 수 있음
		- 영업에 관련된 사용자들은 영업 부문에만 액세스할 수 있음
		- 분석 그룹은 재무와 영업에 동시에 액세스할 수 있음
- 액세스 포인트를 사용함으로써 S3 버킷에 액세스할 다양한 방법을 정의
	- 결과적으로 아주 간단하게 보안을 관리할 수 있게됨
- 각각의 액세스 포인트에 정책을 첨부
	- Amazon S3에는 아주 간단한 버킷 정책을 갖게됨
- 이렇게 해서 S3 버킷에 대한 액세스를 스케일링할 수 있음
- 요약하자면, 액세스 포인트는 S3 버킷의 보안 관리를 간소화해 주고, 각각의 액세스 포인트는 각자의DNS 이름을 갖게됨
	- 그걸로 사용자는 액세스 포인트에 접속하게 됨

### S3 - Access Points - VPC Origin

![se10](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/se10.png)

- 액세스 포인트가 인터넷 오리진에 연결되거나 프라이빗 트래픽인 경우에 VPC 오리진에 연결되도록 할 수 있음
- 그런 다음에 버킷 정책과 아주 비슷한 액세스 포인트 정책을 첨부하고, 그렇게 하면 보안 관리를 스케일링할 수 있게 됨
- S3 액세스 포인트의 VPC 오리진을 프라이빗 액세스가 가능하도록 정의할 수 있음
- 예시
	- VPC의 EC2 인스턴스는 인터넷을 통하지 않고 VPC 액세스 포인트와 VPC 오리진을 통해 S3 버킷에 액세스할 수 있음
	- 그럼 이 VPC 오리진에 액세스하기 위해 액세스 포인트에 액세스하기 위한 VPC 엔드포인트라는 걸 만들어야 함
		- 그건 VPC 안에 있고 VPC 오리진을 통해 액세스 포인트에 사적으로 접속할 수 있게 해줌
	- 이 VPC 엔드포인트에는 정책이 있음
		- 정책은 타깃 버킷과 액세스 포인트에 대한 액세스를 허용해 줘야 함
	- 그럼 VPC 엔드포인트 정책은 EC2 인스턴스가 Amazon S3의 액세스 포인트와 S3 버킷에 모두 접속하게 허용해 줄 것
	- 그럼 VPC 엔드포인트엔 보안이 있음
		- 또한 액세스 포인트 정책에도 보안이 있음
		- 그리고 S3 버킷 수준에도 보안이 있음

### S3 - Access Points - Object Lambda

![se11](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/se11.png)

- S3 액세스 포인트에는 또 다른 활용 사례, S3 객체 람다
- 예시 1
	- S3 버킷이 있는데 호출자 애플리케이션이 객체를 받기 직전에 그 객체를 수정하려는 경우
	- 버킷을 복제해서 버킷에 각 객체의 다른 버전을 갖는 대신에 S3 객체 람다를 사용할 수 있음
		- 그걸 하기 위해 S3 액세스 포인트가 필요
- 예시 2
	- 클라우드가 있고 그 안에는 S3 버킷이 있음
	- 그리고 어떤 전자상거래 애플리케이션이 이 S3 버킷 안의 데이터를 소유
		- 전자상거래 애플리케이션은 직접 S3 버킷에 액세스하고 원본 객체를 받거나 넣을 수 있음
	- 분석기 애플리케이션은 변경된 객체, 즉 약간의 데이터가 삭제된 객체에만 액세스하려고 함
		- 그걸 위해 새로운 S3 버킷을 만들지 않고 S3 버킷 외에 S3 액세스 포인트를 만들 수 있음
		- 그게 람다 함수에 연결되어 있음
			- 람다 함수를 사용하면 클라우드에서 아주 쉽게 코드를 실행할 수 있음
		- 그러면 람다 함수는 객체를 받는 중에 그 객체에서 데이터를 삭제할 것임
		- 그리고 S3 객체 람다 액세스 포인트를 만들 것
		- 분석기 애플리케이션은 이 액세스 포인트로 버킷에 액세스
		- 요약
			- 분석기 애플리케이션은 우리의 S3 객체 람다 액세스 포인트에 액세스
			- 그러면 람다 함수가 호출됨
			- 람다 함수는 S3 버킷에서 데이터를 받고, 어떤 코드를 실행해서 데이터를 삭제
			- 분석기 애플리케이션은 전자상거래 애플리케이션과 동일한 S3 버킷으로부터 데이터가 삭제된 객체를 받게 됨
	- 마케팅 애플리케이션은 데이터가 보강된 객체에 액세스하려고 함
		- 이 애플리케이션은 데이터를 보강하는 고객 충성도 데이터베이스를 갖고 있음
		- 그러면 역시 새로 S3 버킷을 생성하고 모든 보강된 데이터가 있는 객체를 생성하는 대신에 람다 함수를 사용할 수 있음
		- 람다 함수의 코드는 고객 충성도 데이터베이스에서 데이터를 검색해서 데이터를 보강
		- 그러면 별도로 객체 람다 액세스 포인트를 만들 수 있음
		- 그러면 마케팅 애플리케이션은 이 S3 객체 람다 액세스 포인트에 액세스해서 보강된 객체를 받을 수 있음
	- S3 버킷이 하나만 있으면 됨
		- 액세스 포인트와 객체 람다를 만들어서 원하는 대로 데이터를 수정할 수 있음
- Use Cases
	- 분석기나 비프로덕션 환경을 위해 PII 데이터, 즉 개인 식별 정보를 삭제하는 경우
	- 데이터 형식을 XML에서 JSON으로 변환하는 경우
	 - 즉석에서 이미지 크기를 조정하거나 워터마크를 추가하는 등의 원하는 변환을 수행하는 경우
		 - 하지만 워터마크는 객체를 요청하는 사용자에게만 적용될 것임
