# DNS

- DNS: Domain Name System
	- 사람에게 친숙한 호스트 이름을 대상 서버 IP 주소로 번역
	- 웹 브라우저에 www.google.com을 입력하면 IP 주소를 주고 웹 브라우저가 이면에서 여기에 접근하여 구글로부터 데이터를 얻음
- DNS의 계층적 이름 구조
	- .com
	- example.com
	- www.example.com 또는 api.example.com

## DNS 용어

![rt1](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt1.png)

- 도메인 레지스트라 (Registrar)
	- 도메인 이름을 등록하는 곳
	- 아마존 Route 53 또는 GoDaddy가 될 수도 있고 온라인에서 찾을 수 있는 다른 레지스트라들도 있음
- DNS Records: A, AAAA, CNAME, NS, ...
- 존 파일 (Zone File)
	- 모든 DNS 레코드를 포함
	- 호스트 이름과 IP 또는 주소를 일치시키는 방법
- 이름 서버 (Name Server)
	- DNS 쿼리를 실제로 해결하는 서버
- 최상위 도메인 (TLD, Top Level Domain)
	- .com, .us, .in, .gov, .org 등
- 2단계 도메인 (SLD, Second Level Domain)
	- amazon.com, google.com 등
	- 단어 사이에 '.'이 있는 것을 볼 수 있음
- FQDN 또는 전체 주소 도메인 이름 (Fully Qualified Domain Name)
	- 예시: http://api.www.example.com.
		- 마지막 .을 루트라고 함
		- 전체 도메인 이름의 루트
		- www.example.com이 서브 도메인
		- api.www.example.com이 도메인 이름
		- HTTP 부분은 사용하기를 원하는 프로토콜

## DNS의 동작 

![rt2](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt2.png)

- 공인 IP: 9.10.11.12
- 도메인 이름 example.com을 이용해서 접근하고자 함
- example.com이란 도메인 이름을 DNS용 서버를 등록해야 함
- 웹 브라우저가 example.com에 접근하기 위해서는 로컬 DNS 서버에 물어볼 것
	- 'example.com을 아십니까?'
	- 로컬 DNS 서버는 보통 회사에 의해 할당되고 관리됨
	- 또는 인터넷 서비스 제공자에 동적으로 할당됨
- 로컬 DNS 서버가 이 쿼리를 전에 본 적이 없다면 먼저 ICANN에 의해 관리되는 루트 DNS 서버에 물어볼 것
	- ICANN 조직에 'example.com을 아십니까?'라고 물어봄
- 가장 먼저 요청되는 서버인 루트 DNS 서버는 '본 적 없어요, 그러나 .com은 알고 있습니다'라고 함
	- .com은 이름 서버(NS) 레코드로 공인 IP 1.2.3.4로 가보라고 알려줌
- 로컬 DNS 서비스는 '좋아요, 최상단 도메인에 물어보겠습니다'라고 함
	- 따라서 1.2.3.4.에 있는 .com 도메인 서버에게 쿼리의 답을 요청할 것
	- IANA에 의해 관리되는 또 다른 도메인
- TLD DNS 서버에 example.com을 다시 물어보게 됨
	- 'example.com을 아십니까?'
- DNS 서버는 example.com이 무엇인지 몰라서 쿼리에 당장 답할 수가 없음
	- 그러나 example.com이라는 서버는 알고 있음
	- 5.6.7.8에 있음
		- 다음 질문을 할 공용 IP
- 로컬 DNS 서버는 최종 서버로 서브도메인의 DNS 서버
	- 이는 도메인 이름 레지스트라에 의해 관리되는 서버
	- 예를 들어 아마존 Route 53 등
- 로컬 DNS 서버는 'example.com을 아십니까?'라고 물어보고 SLD DNS 서버에는 example.com에 대한 항목이 있음
	- 'example.com이 무엇인지 알고 있죠'라고 하고 example.com은 A 레코드이고 이것의 결과로 IP 9.10.11.12를 얻음
	- DNS 서버가 이제 답을 알고 있음
- DNS 서버에 반복적으로 물어보며 가장 구체적인 것을 찾음
- 만약 누군가가 다시 example.com을 물어본다면 바로 답변을 줄 수 있음
	- 로컬 DNS 서버는 답변을 웹 브라우저에 보내고 브라우저는 답변을 받음

# Amazon Route 53

![rt3](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt3.png)

- Route53: 고가용성, 확장성을 갖춘, 완전히 관리되며 권한있는 DNS
	- 권한이 있다는 것이 무슨 뜻?
		- 고객인 사용자가 DNS 레코드를 업데이트할 수 있다는 것
		- 즉, DNS에 대한 완전히 제어할 수 있음
- Route 53 역시 도메인 이름 레지스트라
- Route 53의 리소스 관련 상태 확인을 확인할 수 있음
- 100% SLA 가용성을 제공하는 유일한 AWS 서비스
- 왜 Route 53이라고 하는지?
	- 53은 DNS 서비스, 즉, 이름에서 사용되는 전통적인 DNS 포트

## Route 53 - Records

- Route 53에서 여러 DNS 레코드를 정의하고 레코드를 통해 특정 도메인으로 라우팅하는 방법을 정의
- 라우팅 정책: Route 53이 쿼리에 응답하는 방식
- TTL: DNS 리졸버(resolver)에서 레코드가 캐싱 되는 시간
- Route 53에서 지원하는 DNS 레코드 종류는 많은데 반드시 알아야 하는 것은 A, AAAA, CNAME, 그리고 NS

### Record types

- A
	- 호스트 이름과 IPv4 IP를 매핑
	- 예를 들어 example.com은 1.2.3.4로 바로 연결됨
-  AAAA
	- A와 비슷한 아이디어로, 호스트 이름을 IPv6 주소에 매핑
- CNAME
	- 호스트 이름을 다른 호스트 이름과 매핑
	- 물론 대상 호스트 이름은 A나 AAAA 레코드가 될 수 있음
	- Route 53에서 DNS 이름 공간 또는 Zone Apex의 상위 노드에 대한 CNAMES를 생성할 수 없음
	- 예를 들어 example.com에 CNAME을 만들 수는 없지만 www.example.com에 대한 CNAME 레코드는 만들 수 있음
- NS
	- 호스팅 존의 이름 서버
	- 서버의 DNS 이름 또는 IP 주소로 호스팅 존에 대한 DNS 쿼리에 응답할 수 있음
	- 또한 트래픽이 도메인으로 라우팅 되는 방식을 제어

## Route 53 - Hosted Zones

- 호스팅 존: 레코드의 컨테이너
- 도메인과 서브도메인으로 가는 트래픽의 라우팅 방식을 정의

### Hosted Zones types

- 퍼블릭 호스팅 존
	- 퍼블릭 도메인 이름을 살 때마다 mypublicdomain.com이 퍼블릭 도메인 이름이라면 퍼블릭 호스팅 존을 만들 수 있음
	- 퍼블릭 존은 쿼리에 도메인 이름 application1.mypublicdomainname.com의 IP가 무엇인지 알 수 있음
- 프라이빗 호스팅 존
	- 공개되지 않는 도메인 이름을 지원
	- 가상 프라이빗 클라우드(VPC)만이 URL을 리졸브 할 수 있음
	- application1.company.internal 같은 경우에 사용
	- 사기업에는 때때로 회사 네트워크 내에서만 접근할 수 있는 URL이 있음
	- 이면에는 프라이빗 DNS 레코드가 있음
- AWS에서 만드는 어떤 호스팅 존이든 월에 50센트를 지불해야 함

### Public vs Private Hosted Zones

![rt4](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt4.png)

- 퍼블릭 호스팅 존은 공개된 클라이언트로부터 온 쿼리에 응답할 수 있음
	- 웹 브라우저에서 example.com을 요청하면 IP를 반환
- 프라이빗 호스팅 존의 경우 해당 VPC에서만 동작
	- 비공개 도메인 이름의 프라이빗 리소스를 식별할 수 있게 함
	- 예를 들어 EC2 인스턴스 1개가 있고 webapp.example.internal을 식별하고자 함
		- 또 다른 EC2 인스턴스에서는 api.example.internal을 식별하기 원하고 데이터베이스에서는 db.example.internal을 식별하고자 함
		- 프라이빗 호스팅 존에 등록하려고 하는데 첫 번째 EC2 인스턴스가 api.example.internal을 요청하는 경우 프라이빗 호스팅 존은 프라이빗 IP 10.0.0.10이라는 답을 갖고 있음
		- EC2 인스턴스는 데이터베이스에 연결이 필요할 수도 있는 두 번째 EC2 인스턴스에 연결
		- database.example.internal가 무엇인지 물어보면 프라이빗 호스팅 존은 프라이빗 IP를 알려줌
- 퍼블릭 호스팅 존은 프라이빗 호스팅 존과 똑같이 동작하지만 퍼블릭 호스팅 존은 누구든 여러분의 레코드를 쿼리 할 수 있음
	- 퍼블릭 레코드를 위한 호스팅 존
- 프라이빗 호스팅 존은 오직 프라이빗 리소스, 예컨대, VPC에서만 쿼리 할 수 있음

## Route 53 - Records TTL (Time to Live)

![rt5](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt5.png)

- 클라이언트가 DNS route 53와 웹 서버에 접속한다고 가정
- myapp.example.com에서 DNS 요청을 보내면 DNS로부터 회신을 받음
- 회신 내용: A 레코드와 IP 주소 그리고 TTL이 있으며 TTL은 300초
	- TTL은 클라이언트에게 이 결과를 캐시하도록 요청
- 300초 동안 클라이언트는 결과를 캐시
	- 다시 말해, 클라이언트가 재요청을 보내거나 같은 호스트 이름으로 접속할 경우 클라이언트는 DNS 시스템에게 쿼리를 보내지 않아도 된다는 의미
	- 이미 답변을 캐시에 저장했기 때문에 답을 알고 있기 때문
- 웹 서버에 접속이 가능하며 HTTP 요청 및 회신을 보낼 수 있음

### 예시: 두 가지의 극단적인 경우

- TTL을 24시간으로 높게 설정한다면 Route 53의 트래픽은 현저히 적을 것
	- 결과가 24시간 동안 캐시될 테니 클라이언트는 요청을 적게 보낼 것
	- 하지만 클라이언트가 오래된 레코드를 받을 가능성도 있음
	- 따라서 만약 레코드를 바꾸고자 한다면 모든 클라이언트들이 새 레코드를 캐시에 저장할 때까지 24시간을 기다려야 한다는 뜻
- 반대로 TTL을 60초 정도로 짧게 설정한다면 DNS에는 트래픽의 양이 많아져서 비용이 많이 듬
	- Route 53에 들어오는 요청의 양에 따라 요금이 책정되기 때문
	- 하지만 오래된 레코드의 보관 시간은 짧아짐
	- 따라서 레코드 변경이 빨라짐
	- 레코드 변경 전반이 더욱 편리
- 어떤 TTL 설정이 더 적합할지는 상황에 따라 달라짐
	- 레코드를 변경하려는 경우 예를 들어 TTL을 24시간으로 늦춘 다음 모든 클라이언트가 느린 새 TTL을 가지고 있다는 점을 확인한 후, 레코드 값을 바꿔서 모두에게 업데이트가 되면 TTL을 올리는 식

## CNAME vs Alias

- 로드 밸런서나 CloudFront 등 AWS의 리소스를 사용하는 경우 호스트 이름이 노출되고, 보유한 도메인에 호스트 이름을 매핑하고자 할 수도 있음
- 예시: myapp.mydomain.com에 이 로드 밸런서를 매핑하는 경우
	- 두 가지 옵션이 있음
		- 첫 번째는 CNAME 레코드
			- CNAME은 호스트 이름이 다른 호스트 이름으로 향하도록 할 수 있음
			- 예를 들어 app.mydomain.com이 blabla.anything.com으로 향하는 식
			- 이건 루트 도메인 이름이 아닌 경우에만 가능해서 mydomain.com 앞에 뭔가 붙어야 함
		- 두 번재는 별칭 레코드 (Alias)
			- 이건 Route 53에 한정되지만 호스트 이름이 특정 AWS 리소스로 향하도록 할 수 있음
			- 예를 들어 app.mydomain.com이 blabla.amazonaws.com를 향할 수 있음
			- 별칭 레코드는 루트 및 비루트 도메인 모두에 작동
			- mydomain.com을 별칭으로 사용해 AWS 리소스로 향하도록 할 수 있기 때문에, 아주 유용
			- 별칭의 장점으로는 무료이고 자체적으로 상태 확인이 가능하다는 점이 있음

### Alias Records

![rt6](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt6.png)

- 별칭 레코드는 AWS의 리소스에만 매핑이 되어 있음
- 예를 들어 Route 53에서 example.com을 A 레코드의 별칭 레코드로 하고 그 값은 로드 밸런서의 DNS 이름을 지정하려 한다고 가정
	- 이건 DNS의 확장 기능으로 시중의 모든 DNS에서 가능
	- 만약 기반 ALB에서 IP가 바뀌면 별칭 레코드는 이걸 바로 인식할 것임
	- CNAME과 달리, 별칭 레코드는 Zone Apex라는 DNS 네임스페이스의 상위 노드로 사용될 수 있음
		- example.com에도 별칭 레코드를 쓸 수 있는 것
- AWS 리소스를 위한 별칭 레코드의 타입은 항상 A 또는 AAAA인데 리소스는 IPv4나 IPv6 중 하나
- 별칭 레코드를 사용하면 TTL을 설정할 수 없음
	- Route 53에 의해 자동으로 설정됨

#### Alias Records Targets

- 일래스틱 로드 밸런서(Elastic Load Balancer)
- CloudFront 배포도 가능
- API Gateway
- 일래스틱 빈스톡 환경
- S3 웹사이트도 가능
- VPC 인터페이스 엔드포인트
- Global Accelerator 가속기
- 동일 호스트 존의 Route 53
- 등등
- **EC2의 DNS 이름에 대해서는 별칭 레코드를 설정할 수 없음**

## Routing Policies

- 라우팅 정책은 Route 53가 DNS 쿼리에 응답하는 것을 도움
- 여기서 라우팅이라는 단어를 혼동하셔서는 안 됨
	- 로드 밸런서가 트래픽을 백엔드 EC2 인스턴스로 라우팅하는 것과는 다른 상황
- 여기서의 라우팅은 DNS 관점
	- DNS는 트래픽을 라우팅하지 않음
	- 트래픽은 DNS를 통과하지 않음
	- DNS는 DNS 쿼리에만 응답하게 되고 클라이언트들은 이를 통해 HTTP 쿼리 등을 어떻게 처리해야 하는지를 알 수 있게 되는 것
- DNS는 호스트 이름들을 클라이언트가 실제 사용 가능한 엔드 포인트로 변환하는 것을 도움
- 다음은 Route 53가 지원하는 라우팅 정책
	- 단순
	- 가중치 기반
	- 장애 조치
	- 지연 시간 기반
	- 지리적
	- 다중 값 응답
	- 지리 근접 라우팅 정책

### Route 53 - Health Checks

![rt10](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt10.png)

- 상태 확인은 주로 공용 리소스에 대한 상태를 확인하는 방법
	- 개인 리소스의 상태를 확인하는 방법 또한 존재
- 예시
	- 서로 다른 두 지역에 각 하나씩의 로드 밸런서가 있고 둘은 모두 공용 로드 밸런서라고 가정
	- 그리고 그 둘의 뒤에서 애플리케이션이 작동 중
		- 다중 지역 셋업
		- 지역 레벨에서 고가용성을 원하는 상황
	- 그리고 Route 53을 이용해 DNS 레코드를 만들 것
	- 유저가 mydomain.com과 같은 URL을 이용해 접속하면 해당 유저는 가장 가까운 로드 밸런서로 연결됨
		- 지연 시간 기반 레코드
		- 하지만 만약 한 지역이 사용 불가능 상태가 되면 유저를 그곳으로 보내지 않기 위해 Route 53에서 상태 확인을 생성해야 함
	- us-east-1의 인스턴스와 eu-west-1의 인스턴스에 상태 확인을 생성
		- 이 두 개의 상태 확인을 Route 53의 레코드와 연결할 수 있게 됨
		- 이는 DNS의 장애 조치를 자동화하기 위한 작업
- 세 가지의 상태 확인이 가능
	- 공용 엔드 포인트를 모니터링하는 것
		- 애플리케이션, 서버, 혹은 다른 AWS 리소스가 될 수 있음
	- 다른 상태 확인을 모니터링하는 상태 확인
		- 계산된 상태 확인
	- CloudWatch 경보의 상태를 모니터링하는 상태 확인
		- 제어가 쉽고 개인 리소스들에 아주 유용
		- 이 상태 확인들은 각자의 메트릭을 사용하는데 CloudWatch의 지표에서도 확인이 가능

#### Health Checks - Monitor an Endpoint

![rt11](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt11.png)

- 15개의 글로벌 헬스 체커가 엔드 포인트의 상태 확인
	- 임계값을 정상 혹은 비정상으로 설정
	- 간격도 설정 가능
		- 30초마다 정기적으로 확인할 수 있음
		- 비용이 더 들지만 10초마다 할 수도 있음
			- 빠른 상태 확인
	- HTTP, HTTPS와 TCP 등 많은 프로토콜을 지원
	- 18% 이상의 상태 확인이 엔드 포인트를 정상이라고 판단하면 Route 53도 이를 정상이라고 간주
		- 그렇지 않다면 비정상인 것으로 인식
	- 상태 확인에 사용될 위치도 선택 가능
- 상태 확인은 로드 밸런서로부터 2xx나 3xx의 코드를 받아야만 통과
- 텍스트 기반 응답일 경우 상태 확인은 응답의 처음 5,120바이트를 확인
	- 응답 자체에 해당 텍스트가 있는지 보기 위함
- 상태 확인의 작동이 가능하려면 상태 확인이 애플리케이션 밸런서나 엔드 포인트에 접근이 가능해야 함
	- 따라서 Route 53의 상태 확인 IP 주소 범위에서 들어오는 모든 요청을 허용해야 함

#### Health Checks - Calculated Health Checks

![rt12](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt12.png)

- 계산된 상태 확인은 여러 개의 상태 확인 결과를 하나로 합쳐주는 기능
- 위 Route 53을 보면 EC2 인스턴스가 세 개 있고 상태 확인을 세 개 생성할 수 있음
	- 이들은 EC2 인스턴스를 하나씩 확인해 주는 하위 상태 확인
	- 이 하위 상태 확인을 바탕으로 상위 상태 확인을 정의할 수 있음
- 상태 확인들을 모두 합치기 위한 조건은 OR와 AND 또는 NOT
- 하위 상태 확인을 256개까지 모니터링할 수 있음
- 상위 상태 확인이 통과하기 위해 몇 개의 상태 확인을 통과해야 하는지도 지정할 수 있음
- 사용하는 경우
	- 예를 들어 상태 확인이 실패하는 일 없이 상위 상태 확인이 웹사이트를 관리 유지하도록 하는 경우

#### Health Checks - Private Hosted Zones

![rt13](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt13.png)

- 개인 리소스의 상태 확인
	- 개인의 리소스를 모니터링하는 것은 어려울 수 있음
	- 모든 Route 53의 헬스 체커는 공용 웹에 있고 이들은 VPC의 외부에 있음
		- 개인 엔드 포인트에 접근이 불가능
		- 개인 VPC나 온프레미스 리소스인 경우
- CloudWatch 지표를 만들어 CloudWatch 알람을 할당하는 식으로 문제를 해결
	- 그러면 CloudWatch 경보를 상태 확인에 할당할 수 있음
- CloudWatch 메트릭을 이용해 개인 서브넷 안에 있는 EC2 인스턴스를 모니터
	- 그리고 메트릭이 침해되는 경우 CloudWatch 알람을 생성
	- 알람이 ALARM 상태가 되면 상태 확인은 자동으로 비정상이 됨 (Unhealthy)
	- 이렇게 하면 개인 리소스에 대한 상태 확인을 만든 것이나 다름 없음

### Routing Policies - Simple

![rt7](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt7.png)

- 기존에 우리가 사용해 왔던 방식
- 일반적으로 트래픽을 단일 리소스로 보내는 방식
- 예를 들어 클라이언트가 foo.example.com으로 가고자 한다고 하면 Route 53이 IP 주소를 알려주는 것
	- A 레코드 주소
- 동일한 레코드에 여러 개의 값을 지정하는 것도 가능
	- 이렇게 DNS에 의해 다중 값의 받은 경우에는 클라이언트 쪽에서 그 중 하나를 무작위로 고르게 됨
- 이 예시의 경우에는 클라이언트가 foo.example.com로 가기를 요청하고, Route 53은 세 개의 IP 주소로 답함
	- A 레코드에 임베딩된 주소들
	- 그럼 클라이언트가 셋 중 하나를 골라서 라우팅에 적용
- 단순 라우팅 정책에 별칭 레코드를 함께 사용하면 하나의 AWS 리소스만을 대상으로 지정할 수 있음
- 상태 확인은 할 수 없음

### Routing Policies - Weighted

![rt8](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt8.png)

- 가중치 기반 라우팅 정책을 사용하면, 가중치를 활용해 요청의 일부 비율을 특정 리소스로 보내는 식의 제어가 가능
- 도면을 보면 Amazon Route 53이 있고 EC2 인스턴스가 세 개 있는데 70, 20, 그리고 10의 각각 다른 가중치를 할당받아 Amazon Route 53에서 오는 DNS 응답의 70%가 첫 번째 EC2 인스턴스로 리다이렉팅된다는 의미
	- 20퍼센트는 두 번째로 10퍼센트는 세 번째 인스턴스로 감
	- 따라서, 각 레코드에 상대적으로 가중치를 할당하게 되는 것
- 각 레코드로 보내지는 트래픽의 양(%)은 해당 레코드의 가중치를 전체 가중치로 나눈 값
- 가중치 합은 100이 아니어도 됨
- 한 DNS 이름 하에 있는 다른 레코드들과 비교했을 때 해당 레코드로 트래픽을 얼마나 보낼지를 나타내는 값
- 이렇게 하려면 DNS 레코드들은 동일한 이름과 유형을 가져야 하며 상태 확인과도 관련될 수 있음
- 가중치 기반 정책이 사용되는 경우는 제법 명확
	- 서로 다른 지역들에 걸쳐 로드 밸런싱을 할 때
	- 적은 양의 트래픽을 보내 새 애플리케이션을 테스트하는 경우에도 사용
- 가중치 0의 값을 보내게 되면 특정 리소스에 트래픽 보내기를 중단해 가중치를 바꿀 수 있음
- 모든 리소스 레코드 가중치의 값이 0인 경우에는 모든 레코드가 다시 동일한 가중치를 갖게 됨

### Routing Policies - Latency Based

![rt9](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt9.png)

- 지연 시간 기반 라우팅 정책이란 지연 시간이 가장 짧은, 즉 가장 가까운 리소스로 리다이렉팅을 하는 정책
- 지연 시간에 민감한 웹사이트나 애플리케이션이 있는 경우에 아주 유용한 정책
- 지연 시간은 유저가 레코드로 가장 가까운 식별된 AWS 리전에 연결하기까지 걸리는 시간을 기반으로 측정됨
- 만약 유저가 독일에 있고 미국에 있는 리소스의 지연 시간이 가장 짧다면, 해당 유저는 미국 리전으로 리다이렉팅이 될 것임
- 상태 확인과 연결이 가능

### Routing Policies - Failover (Active-Passive)

![rt14](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt14.png)

- 장애 조치
- 여기 중간에 Route 53이 있고 EC2 인스턴스가 있음
	- 하나는 기본 EC2 인스턴스이고 두 번째는 보조 EC2 인스턴스 혹은 재해 복구 EC2 인스턴스
	- 이 경우에는 상태 확인과 기본 레코드를 연결하는데 이는 필수적임
- 상태 확인이 비정상이면 자동으로 Route 53은 2번째의 EC2 인스턴스로 장애 조치하며 결과를 보내기 시작
- 보조 EC2 인스턴스도 상태 확인을 연결할 수 있지만 기본과 보조가 각각 하나씩만 있을 수 있음
- 클라이언트의 DNS 요청은 정상으로 생각되는 리소스를 자동으로 얻음
	- 기본 인스턴스가 정상이면 Route 53도 기본 레코드로 응답
	- 하지만 상태 확인이 비정상이면 장애 조치에 도움이 되는 두 번째 레코드의 응답을 자동으로 얻음

### Routing Policies - Geolocation

![rt15](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt15.png)

- 지리 위치(Geolocation) 라우팅 정책
- 지연 시간 기반의 정책과는 매우 다르게 사용자의 실제 위치를 기반으로 함
- 예를 들어 사용자가 특정 대륙이나 국가 혹은 더 정확하게 미국의 경우에는 어떤 주에 있는지 지정하는 것이며 가장 정확한 위치가 선택되어 그 IP로 라우팅 되는 것
- 일치하는 위치가 없는 경우는 기본 레코드를 생성해야 함
- 사용 사례
	- 콘텐츠 분산을 제한하고 로드 밸런싱 등을 실행하는 웹사이트 현지화
		- 이런 레코드는 상태 확인과 연결할 수 있음
- 예시
	- 여러 나라가 있는 유럽의 지도를 가정
	- 독일의 유저가 독일어 버전의 앱을 포함한 IP로 접속되도록 독일의 지리 레코드를 정의할 수 있음
	- 프랑스의 경우라면 프랑스어의 버전의 앱을 가진 IP로 가야함
	- 그 외의 다른 곳은 앱에서 영어 버전이 포함된 기본 IP로 이동

### Routing Policies - GeoProximity

- 지리 근접 라우팅
- 이는 사용자와 리소스의 지리적 위치를 기반으로 트래픽을 리소스로 라우팅하도록 함
- 이 정책으로 편향값을 사용해 특정 위치를 기반으로 리소스를 더 많은 트래픽을 이동하는 것
- 지리적 위치를 변경하려면 편향값을 지정해야 함
	- To expand (1 to 99) – more traffic to the resource  
		- 특정 리소스에 더 많은 트래픽을 보내려면 편향값을 증가시켜서 확장
	- To shrink (-1 to -99) – less traffic to the resource
		- 리소스에 트래픽을 줄이려면 편향값을 음수로 축소
- 리소스
	- AWS의 리소스로 속한 특정 리전을 지정하면 목록에서 자동으로 올바른 라우팅을 계산
	- AWS 리소스가 아닌 온프레미스 데이터 센터인 경우 위도와 경도를 지정해서 AWS가 위치를 파악하도록 해야 함
- 편향 활용을 위해 고급 Route 53 트래픽 플로우를 사용해야 함

![rt17](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt17.png)

- 예시
	- us-west-1의 리소스와 us-east-1 리소스가 있음
	- 각 리전의 편향값은 0으로 설정됨
		- 이는 미국 전역에 사용자가 이 리소스에 액세스를 시도하며 미국을 둘로 나눈다는 뜻
	- 왼쪽의 사용자는 us-west-1로 이동하고 오른쪽 사용자는 us-east-1로 이동
	- 편향이 없기 때문에 사용자는 사용자 위치에서 가장 가까운 리소스 리전으로 이동

![rt16](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt16.png)

- 편향으로 동일한 설정이지만 다른 방식으로 사용자를 다른 리전으로 라우팅할 수 있음
- 예시
	- us-west-1과 us-east-1이 있고 us-west-1의 편향값은 0이고 us-east-1의 50이라는 양수의 편향값을 가짐
	- 그러면 편향으로 us-east-1 리소스에 더 많은 사용자와 트래픽이 발생됨
	- 편향으로 2가지 리소스 사이의 분할 선이 조금씩 왼쪽으로 이동
		- 이는 us-east-1의 편향이 더 높기 때문
	- 왼쪽의 사용자는 us-west-1으로 이동하고 오른쪽의 사용자는 us-east-1으로 이동
- 예를 들어, 전 세계로 리소스를 설정하고 특정 리전에 더 많은 트래픽을 더 보내야 한다고 하면 지리 근접 라우팅 정책을 사용해 특정 리전의 편향을 증가시켜 더 많은 사용자가 생기게 되고 특정 리전에 더 많은 트래픽이 발생하게 됨
- **지리 근접 라우팅은 편향을 증가시켜 한 리전에서 다른 리전으로 트래픽을 보낼 때 유용**

### Routing Policies - IP-based Routing

![rt18](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt18.png)

- IP 기반 라우팅
- 클라이언트 IP 주소를 기반으로 라우팅을 정의
- Route 53에서 CIDR 목록을 정의
	- 클라이언트의 IP 범위
	- 그리고 CIDR에 따라 트래픽을 어느 로케이션으로 보내야 하는지 정함
- 장점
	- 성능을 최적화할 수 있음
	- 네트워크 비용도 절감 가능
- 특정 인터넷 제공업체가 특정 IP 주소 셋을 사용하는 걸 안다면 특정 엔드포인트로 라우팅할 수 있음
- 예시
	- Route 53에서 두 로케이션을 서로 다른 두 CIDR 블록으로 정의
	- 하나는 203으로 시작하고 다른 하나는 200으로 시작, 그러면 IP 범위도 정의됨
	- 로케이션을 레코드에 연결
		- example.com
		- 로케이션 1에서는 첫 번째 CIDR 블록을 값 1, 2, 3, 4로 보냄
		- 두 번째 로케이션에서는 두 번째 CIDR 블록을 5, 6, 7, 8로 보냄
		- 이 값들은 두 개의 EC2 인스턴스의 공용 IP를 나타냄
	- 사용자 A가 로케이션 1 CIDR 블록에 속하는 특정 IP로 들어오면 첫 번째 EC2 인스턴스인 IP 1, 2, 3, 4로 보내짐
	- 사용자 B가 두 번째 로케이션에 속하는 IP 주소로 들어오면 리디렉션되어 IP 5, 6, 7, 8의 EC2 인스턴스에 대한 DNS 쿼리 응답을 받게됨

### Routing Policies - Multi-Value

![rt19](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt19.png)

- 다중 값 (Multi-Value)
- 트래픽을 다중 리소스로 라우팅할 때 사용
- Route 53은 다중 값과 리소스를 반환
- 상태 확인과 연결하면 다중 값 정책에서 반환되는 유일한 리소스는 정상 상태 확인과 관련 있음
- 각각의 다중 값 쿼리에 최대 8개의 정상 레코드가 반환됨
- ELB와 유사해 보이지만 ELB를 대체할 수는 없음
	- 클라이언트 측면의 로드 밸런싱인 것
- 예시
	- example.com에서 다중 A 레코드를 설정하고 상태 확인과 연결
	- 클라이언트에서 다중 값 쿼리를 실행하면 최대 8개의 레코드를 수신하게 되고 클라이언트는 하나를 선택
	- 하지만 상태 확인과 결합하면 최소한 반환되는 8개 레코드 중 1개 혹은 최대 8개의 레코드가 정상일 것을 알고 있음
		- 그래서 클라이언트는 안전한 쿼리를 가질 수 있음
- 다중 값이 있는 단순 라우팅 정책의 경우, 단순 라우팅 정책은 상태 확인을 허용하지 않기 때문에 단순 라우팅 정책의 쿼리가 반환하는 리소스 중 하나는 비정상일 가능성이 있음
	- 다중 값이 조금 더 강력한 레코드 유형인 이유

## Domain Registrar vs DNS Service

![rt20](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/rt20.png)

- 도메인 이름 레지스트라를 통해 원하는 도메인 이름을 구매할 수 있음
	- 매년 비용을 지불해야 함
- Route 53 콘솔을 통한 Amazon 레지스트라 뿐만 아니라 다른 도메인 이름 레지스트라를 이용해도 괜찮음
	- GoDaddy, Google 도메인 등
- 대게 레지스트라를 통해 도메인을 등록하면 DNS 레코드 관리를 위한 DNS 서비스를 제공
	- 그래서 Amazon 호스트 이름으로 DNS 이름을 등록했다면 DNS 레코드 관리를 위한 Route 53 호스팅 존을 가짐
- 하지만 DNS 레코드로 AWS Route 53 등을 사용하지 않고 Amazon 레지스트라를 사용하거나 반대로 GoDaddy로 도메인을 등록해도 됨
	- example.com에서 구매하고 DNS 레코드는 Amazon의 Route 53으로 관리하는 것도 완벽히 허용되는 조합
- 예시
	- GoDaddy에서 도메인을 등록하면 이름 서버 옵션이 생기는데 사용자 정의 이름 서버를 지정할 수 있음
	- 사용자 정의 네임 서버 지정
		- 먼저 Amazon Route 53에서 원하는 도메인의 공용 호스팅 영역을 생성하고 호스팅 영역 상세의 오른쪽 부분에서 이름 서버를 찾음
			- 여기 있는 4개의 이름 서버는 GoDaddy 웹사이트에서 변경해야 함
		- 이제 GoDaddy에서 사용할 이름 서버에 관한 쿼리에 응답하면 이름 서버가 Amazon의 Route 53 이름 서버를 가리킴
	- 이렇게 Amazon Route 53을 사용해서 해당 콘솔에서 직접 전체 DNS 레코드를 관리
- 정리하자면, 도메인을 타사 등록 대행사에서 구매해도 DNS 서비스 제공자로 Route 53을 사용 가능한데 사용하려면 Route 53에서 공용 호스팅 영역을 생성한 뒤 도메인을 구매한 타사 웹사이트에서 NS 혹은 이름 서버를 업데이트하면 Route 53 이름 서버를 가리키게 됨
- 도메인 이름 레지스트라는 모두 비슷해 보이지만 DNS 서비스가 다름
