# Kinesis

## Kinesis Overview

- Kinesis를 활용하면 실시간 스트리밍 데이터를 손쉽게 수집하고 처리하여 분석할 수 있음
- 실시간 데이터에는 애플리케이션 로그, 계측, 웹 사이트 클릭 스트림, IoT 원격 측정 데이터 등 어떤 것도 포함될 수 있음
- 데이터가 빠르게 실시간으로 생성된다면 모두 실시간 데이터 스트림으로 간주할 수 있음
- Kinesis는 네 가지 서비스로 구성되어 있음
	- Kinesis Data Stream: 데이터 스트림을 수집하여 처리하고 저장
	- Kinesis Data Firehose: 데이터 스트림을 AWS 내부나 외부의 데이터 저장소로 읽어 들임
	- Kinesis Data Analytics: SQL 언어나 Apache Flink를 활용하여 데이터 스트림을 분석
	- Kinesis Video Stream: 마지막으로 시험에는 나오지 않지만 알아 두면 좋을 서비스, 비디오 스트림을 수집하고 처리하여 저장

## Kinesis Data Stream

![kns](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/kns1.png)

- Kinesis Data Stream은 시스템에서 큰 규모의 데이터 흐름을 다루는 서비스
- Kinesis Data Stream은 여러 개의 샤드로 구성되어 있고 이 샤드는 1번, 2번에서 N번까지 번호가 매겨짐
	- 이건 사전에 프로비저닝해야 함
		- 예를 들어, Kinesis Data Stream을 시작할 때 스트림을 여섯 개 샤드로 구성하겠다고 결정해야 함
	- 데이터는 모든 샤드에 분배됨
	- 샤드는 데이터 수집률이나 소비율 측면에서 스트림의 용량을 결정
- 예시
	- 생산자가 있음
		- 이 생산자는 데이터를 Kinesis Data Stream으로 보냄
		- 생산자는 다양
			- 애플리케이션일 수도 있고, 데스크톱이나 휴대전화와 같은 클라이언트일 수도 있고, 매우 낮은 수준에서 AWS SDK를 활용하거나 더 높은 수준에서 Kinesis Producer Library (KPL)을 활용하기도 함
			- 또는 Kinesis Agent를 활용해서 스트리밍할 서버, 예를 들면 Kinesis 스트림에서 애플리케이션 로그를 처리할 수도 있음
			- 모든 생산자는 정확히 동일한 작업을 함
				- 매우 낮은 수준에서 SDK에 의존하며 Kinesis Data Stream에 레코드를 전달
	- 레코드는 근본적으로 두 가지 요소로 구성
		- 파티션 키와 최대 1MB 크기의 데이터 블롭으로 구성
		- 파티션 키는 레코드가 이용할 샤드를 결정하는 데 사용되고 데이터 블롭은 값 자체를 의미
	- 이제 생산자는 데이터를 스트림으로 보낼 때 초당 1MB를 전송하거나 샤드당 1초에 천 개의 메시지를 전송할 수 있음
		- 따라서 여섯 개의 샤드가 있다면 초당 6MB를 얻거나 총 6천 개의 메시지를 얻을 수 있음
	- 일단 데이터가 스트림에 들어가면 많은 소비자가 이 데이터를 사용
	- 소비자에도 다양한 종류가 있음
		- 먼저 SDK에 의존하거나 높은 수준에서는 Kinesis Client Library, KCL에 의존하는 애플리케이션이 있고,
		- Kinesis 스트림에서 서버리스로 처리하려는 경우 Lambda 함수도 가능
		- Kinesis Data Firehose도 있고 Kinesis Data Analytics도 있음
		- 이러한 소비자가 레코드를 받으면 여기에는 파티션 키, 샤드에서 레코드의 위치를 나타내는 시퀀스 번호, 데이터 자체를 의미하는 데이터 블롭이 있음
	- Kinesis Data Stream에는 여러 소비 유형이 존재
		- 샤드마다 초당 2MB의 처리량을 모든 소비자가 공유할 수도 있고
		- 아니면 소비자마다 샤드당 1초에 2MB씩 받을 수도 있음
			- 효율성을 높인 소비 유형, 즉 효율성을 높인 팬아웃 방식
	- 다시 정리하자면 생산자가 Kinesis Data Stream에 데이터를 전송하고 데이터는 잠시 거기에 머물면서 여러 소비자에게 읽힘

## Kinesis Data Streams - 특징

- Kinesis Data Stream의 특징
	- 보존 기간은 1일에서 365일 사이로 설정할 수 있음
		- 데이터를 다시 처리하거나 확인할 수 있다는 뜻
	- 데이터가 일단 Kinesis로 들어오면 삭제할 수 없으며 이러한 특징을 불변성이라고 함
	- 데이터 스트림으로 메시지를 전송하면 파티션 키가 추가되고 파티션 키가 같은 메시지들은 같은 샤드로 들어가게 되어 키를 기반으로 데이터를 정렬할 수 있음
- 생산자는 SDK, Kinesis Producer Library (KPL), Kinesis Agent를 사용하여 데이터를 전송할 수 있음
- 소비자는 Kinesis Client Library (KCL)나 SDK를 써서 직접 데이터를 작성할 수 있음
	- 아니면 AWS에서 관리하는 Lambda나 Kinesis Data Firehose, Kinesis Data Analytics를 활용할 수도 있음

## Kinesis Data Streams - Capacity Modes

- 두 가지 용량 유형이 있음
- Provisioned Mode
	- 전통적인 용량 유형
	- 프로비저닝할 샤드 수를 정하고 API를 활용하거나 수동으로 조정
	- Kinesis Data Stream에 있는 각 샤드는 초당 1MB나 1천 개의 레코드를 받아들이고 출력량의 경우에는 각 샤드가 초당 2MB를 받아들임
	- 이는 일반적인 소비 유형이나 효율성을 높인 팬아웃 방식에 적용할 수 있음
	- 다만 샤드를 프로비저닝할 때마다 시간당 비용이 부과되므로 사전에 심사숙고해야 함
	- 사전에 사용량을 계획할 수 있다면 프로비저닝 유형을 선택
- On-demand Mode
	- 새로운 유형
	- 프로비저닝을 하거나 용량을 관리할 필요가 없음
	- 시간에 따라 언제든 용량이 조정됨
	- 기본적으로는 초당 4MB 또는 초당 4천 개의 레코드를 처리하지만 이 용량은 지난 30일 동안 관측한 최대 처리량에 기반하여 자동으로 조정됨
	- 이 유형에서는 시간당 스트림당 송수신 데이터양(GB 단위)에 따라 비용이 부과됨
		- 비용 산정 방식이 다름
	- 사전에 사용량을 예측할 수 없다면 온디맨드 유형을 선택

## Kinesis Data Streams - Security

![kns](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/kns2.png)

- 리전에 배포됨
- 컨트롤 액세스와 인증은 IAM 정책을 사용
	- 샤드를 생성하거나 샤드에서 읽어 들이는 접근 권한을 제어할 수 있음
- Encryption
	- HTTPS로 전송 중 데이터를 암호화
	- 미사용 데이터는 CMS로 암호화
	- 클라이언트 측 암호화
		- 이는 직접 데이터를 암호화하고 해독해야 하기 때문에 수행하기 더 어려움
		- 하지만 그만큼 보안이 더 강화됨
- Kinesis에서 VPC 엔드포인트를 사용할 수 있음
	- 이를 이용하면 Kinesis에 인터넷을 거치지 않고 프라이빗 서브넷의 인스턴스에서 직접 손쉽게 접근할 수 있음
- 모든 API 요청은 CloudTrail로 감시할 수 있음

## Kinesis Data Firehose

![kns](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/kns3.png)

- 생산자에서 데이터를 가져올 수 있는 유용한 서비스이며, 생산자는 Kinesis Data Stream에서 본 무엇이든 될 수 있음
	- 즉, 애플리케이션, 클라이언트, SDK, KPL, Kinesis Agent 모두 Kinesis Data Firehose로 생산 가능
	- 또한, Kinesis Data Stream과 아마존 CloudWatch (로그 및 이벤트), 그리고 AWS IoT도 Kinesis Data Firehose로 생산 가능
- 이 모든 애플리케이션이 Kinesis Data Firehose로 데이터를 전송하면 Kinesis Data Firehose는 람다 기능을 활용해 데이터를 변환할지 선택할 수 있는데, 이는 옵션
	- 일단 데이터를 변환하면 배치로 수신처에 쓸 수 있음
- Kinesis Data Firehose는 소스에서 데이터를 가져오는데, 주로 Kinesis Data Stream
	- 그리고 수신처에 데이터를 쓸 수 있음
	- 이때 Kinesis Data Firehose가 데이터 쓰는 법을 알기 때문에 별도로 코드를 쓸 필요가 없음
- **Kinesis Data Firehose의 수신처 세 종류**
	1. AWS 수신처
		- 이 부분은 꼭 외워야 함
		- Amazon S3
			- 모든 데이터를 아마존 S3에 쓸 수 있음
		- Amazon RedShift
			- 데이터 웨어하우스
			- 여기에 데이터를 쓸 때는 먼저 아마존 S3에 데이터를 쓰면 Kinesis Data Firehose가 복사 명령어를 내보냄
			- 이 복사 명령어가 아마존 S3의 데이터를 아마존 레드시프트로 복사
		- Amazon ElasticSearch 
	2. 써드 파티 파트너 수신처
		- 데이터독, 스플렁크, 뉴렐릭, 몽고DB와 같은 곳으로 Kinesis Data Firehose가 데이터를 전송할 수 있음
		- 이 수신처는 점점 늘어날 수 있음
		- Kinesis Data Firehose가 데이터를 전송할 수 있는 파트너들이 있다는 것만 알아두면 됨
	3. 커스텀 수신처
		- 만약 HTTP 엔드포인트가 있는 자체 API를 보유하고 있다면 Kinesis Data Firehose를 통해 커스텀 수신처로 데이터를 보낼 수도 있음
		- 데이터가 이러한 수신처로 전송되고 나면 두 가지 옵션이 있음
			- 모든 데이터를 백업으로 S3 버킷에 보내기
			- 혹은 수신처에 쓰이지 못한 데이터를 실패 S3 버킷에 보내기
- 정리
	- Kinesis Data Firehose는 완전 관리되는 서비스
	- 관리가 필요하지 않으며, 자동으로 용량 크기가 조정되고, 서버리스이므로 관리할 서버가 없음
	- 레드시프트와 아마존 S3, ElasticSearch와 같은 AWS 수신처로 데이터를 보낼 수도 있고, 스플렁크, 몽고DB, 데이터독, 뉴렐릭 등 써드 파티 파트너로 보낼 수도 있으며 어떤 HTTP 엔드포인트든 커스텀 수신처로도 보낼 수 있음
	- Kinesis Data Firehose를 통하는 데이터에 대해서만 비용을 지불하면 되므로 아주 훌륭한 데이터 과금 모델이라 할 수 있음
	- 또한 근 실시간으로 이루어짐
		- 왜 근 실시간이냐면 Kinesis Data Firehose에서 수신처로 데이터를 배치로 쓰기 때문
		- 전체 배치가 아닌 경우 최소 60초의 지연시간이 발생하거나, 데이터를 수신처에 보내는 데 한 번에 적어도 1MB의 데이터가 있을 때까지 기다려야 함
		- 그렇기에 실시간 서비스가 아니라 실시간에 가까운 서비스
	- 여러 데이터 형식과 데이터 전환, 변환, 압축을 지원하며, 필요하면 람다를 활용해 자체적인 데이터 변환도 쓸 수 있음
	- 실패한 혹은 모든 데이터를 백업S3 버킷에 보낼 수 있음

## Kinesis Data Streams vs Firehose

- 시험에 Kinesis Data Stream을 사용할 경우, Kinesis Data Firehose를 사용해야 하는 경우를 구분해야 하는 문제가 나오곤 함
- Kinesis Data Stream
	- 데이터를 대규모로 수집할 때 쓰는 스트리밍 서비스
	- 생산자와 소비자에 대해 커스텀 코드를 쓸 수 있음
	- 실시간으로 이루어지며 약 70ms 혹은 200ms 정도의 지연시간이 발생
	- 용량을 직접 조정할 수 있어 샤드 분할이나 샤드 병합을 통해 용량이나 처리량을 늘릴 수 있음
	- 제공한 용량만큼 비용을 지불하면 됨
	- 데이터는 1일에서 365일간 저장됨
	- 덕분에 여러 소비자가 같은 스트림에서 읽어 올 수 있고, 반복 기능도 지원
- Kinesis Data Firehose
	- 수집 서비스로 데이터를 아마존 S3나 레드시프트, ElasticSearch 써드 파티 파트너나 자체 HTTP로 스트리밍
	- 완전 관리되며, 서버리스이고, 근 실시간으로 이뤄짐
		- ‘근 실시간(near real-time)’는 시험 문제에서도 잘 살펴야 하는 키워드
	- 자동으로 용량 조정되어 관련해 걱정할 필요 없고, Kinesis Data Firehose를 통과하는 데이터에 대해서만 비용을 지불하면 됨
	- 데이터 스토리지가 없어 Kinesis Data Firehose의 데이터를 반복하는 기능은 지원되지 않음

## Ordering Data into Kinesis - 사례

![kns](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/kns4.png)

- 도로에 트럭이 100대 있고 각각 트럭 ID가 있다고 가정
	- 트럭 1, 트럭 2 그리고 트럭 100까지 도로에 있으며 GPS 위치를 주기적으로 AWS에 보냄
	- 이제 각 트럭의 순서대로 데이터를 소비해서 트럭의 이동을 정확하게 추적하고 그 경로를 순서대로 확인하려고 함
	- 어떻게 Kinesis로 데이터를 전달하는지?
		- 파티션 키를 사용하면 됨
	- 이때 파티션 키 값은 트럭 ID
		- 트럭 1은 트럭 1의 파티션 키를 전송하고 트럭 2는 트럭 2의 파티션 키를 전송
		- 이유는 같은 파티션 키를 지정하면 해당 키가 언제나 동일한 샤드로 전달되기 때문
- 위 사진에 Kinesis 데이터 스트림과 샤드 세 개가 1, 2, 3번 있음
- 총 5대의 트럭이 도로에 있고 Kinesis에 데이터를 전송
- 트럭 ID로 파티션 키를 사용
- 트럭 1이 GPS 데이터를 보낼 때 Kinesis로 트럭 1의 파티션 키를 보내게 되며, 이때 Kinesis는 트럭 1의 파티션 키를 해시
	- 다시 말해 계산을 하는 것
	- 트럭 1의 데이터가 샤드 1번으로 간다는 걸 알아냄
		- 따라서 데이터는 샤드 1번으로 이동
- 이제 트럭 2번도 데이터를 전송
	- 트럭 2번의 파티션 키를 전송
	- Kinesis는 해당 파티션 키를 확인하고 해시를 한 후에 해당 값이 샤드 2번으로 들어가도록 함
- 트럭 3도 마찬가지로 트럭 3의 파티션 키를 전송하는데 Kinesis 데이터 스트림이 이번엔 트럭 3의 키가 샤드 1번으로 이동해야 한다고 결정
	- 샤드 3번으로 갈 필요 없이 이 파티션 키는 샤드 1로 이동하면 된다고 함
- 트럭 4는 샤드 3번으로 이동하고 트럭 5는 샤드 2번으로 감
	- 이렇게 재분할하는 것을 파티션이라고 하기에 파티션 키라고 부름
	- 각 트럭의 파티션 키는 거기에 따른 샤드에 속함
- 트럭 1은 계속 트럭 1이라는 동일한 파티션 키를 전송하므로 데이터가 언제나 같은 샤드로 이동
	- 그러므로 트럭 1의 다음 데이터 지점은 샤드 1로 가고, 트럭 3의 다음 데이터 지점도 샤드 1번으로 계속 이동
	- 즉 트럭 1이 데이터를 보내면 꼭 샤드 1번으로 이동하고 또한 파란색 트럭인 트럭 3이 데이터를 보내도 (샤드 3이라고 말하지만 문맥 상 트럭 3) 샤드 1번에 정렬됨
		- 그 이유는 시간 흐름에 따라 동일한 파티션 키를 사용하도록 했기 때문
		- 따라서 트럭 1과 3의 데이터는 항상 샤드 1에 정렬됨
- 샤드 2번을 보면 트럭 2와 5의 데이터만 여기로 이동
- 그리고 샤드 3번의 경우 트럭 4의 데이터만 이곳으로 전송될 것임
- 이제 트럭 100대와 샤드 5개가 있다고 하면 각 샤드는 평균적으로 20대의 트럭을 가질 것임
	- 하지만 트럭과 각각의 샤드 사이가 직접적으로 연결된 것은 아님
- Kinesis가 파티션 키를 해시해서 어느 샤드로 보낼지 결정
	- 다시 말해 안정된 파티션 키를 얻으면 바로 트럭이 그 데이터를 같은 샤드로 전달하고 그러면 샤드 레벨에서 각 트럭의 순서에 따른 데이터를 얻을 수 있게 됨

## Ordering Data into SQS - 사례

![kns](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/kns5.png)

- SQS 표준 방식에는 순서가 없음
	- 그래서 SQS FIFO라는 선입 선출 방식이 있음
- 이 SQL FIFO의 그룹 ID를 사용하지 않으면 모든 메시지가 소비되는 방식은 보내진 순서에 따르며 소비자는 하나만 존재
- 예시를 보면 옵션이 다양한데, SQS FIFO 대기열에 전송되는 중
- 그러면 전송되는 순서대로 소비자가 수신 받을 것임
- 보다시피 소비자는 하나이기 때문에 두 배치의 메시지를 소비
- 선입선출 방식으로는 판단하기가 쉬움
	- 소비자도 하나만 가질 수 있음
- 트럭이 있다면, 모든 트럭이 FIFO 대기열로 데이터를 보내더라도 소비자는 하나뿐
- 만약 소비자 숫자를 스케일링하고 서로 연관된 메시지를 그룹화하려는 경우 그룹 ID를 사용할 수 있음
	- Kinesis의 파티션 키와 개념이 비슷
	- 그룹 ID를 사용하면 FIFO 대기열은 FIFO 내부에 두 개 그룹이 생기고 정의한 그룹마다 각각 소비자를 가질 수 있게 됨

![kns](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/kns6.png)

- 지금 예시에서는 두 그룹이 있음: 그룹 A와 그룹 B
- 두 개의 소비자인 소비자 1과 소비자 2는 독자적으로 그룹 1과 2를 읽기 할 수 있음
- 중요한 점은 그룹 ID가 많을수록 소비자도 많아진다는 점
	- Kinesis 와는 아주 다른 모델

## Kinesis vs SQS - Ordering

- 트럭은 100대가 있고 Kinesis 샤드가 5개 SQS FIFO 대기열이 1개라고 가정
- Kinesis 데이터 스트림에서 평균적으로 가지는 값은 샤드당 트럭 20대가 될 것임
	- 해시 기능 덕분에 각 트럭은 하나의 샤드에 지정되고 해당 샤드에 계속 머물 것임
	- 그리고 트럭 데이터는 각 샤드에 순서대로 정렬됨
	- 하지만 동시에 가질 수 있는 최대 소비자 개수는 5개뿐
	- 샤드가 5개이고, 샤드마다 하나의 소비자가 필요하기 때문
	- Kinesis 데이터 스트림은 샤드가 5개인 경우에 초당 최대 5MB의 데이터를 수신할 수 있으며 처리량이 꽤 많은 편
- SQS FIFO의 경우에는 SQS FIFO 대기열은 하나뿐
	- 샤드 및 파티션을 정의할 필요 없이 SQS FIFO 대기열이 하나만 있음
	- 트럭이 100대 있으므로 각 트럭 ID에 상응하는 그룹 ID를 100개 생성
	- 즉 그룹 ID가 100개가 되고 소비자도 최대 100개가 될 수 있음
		- 각 소비자가 특정한 그룹 ID와 연결되기 때문
	- 규모를 보면 SQS FIFO에서 최대 초당 300, 혹은 배치를 사용하면 3,000개의 메시지를 가짐
- 이렇듯 서로 다른 소비, 생산 그리고 정렬 모델에서 기억할 점은 경우에 따라 적절한 모델은 달라짐
	- SQS FIFO는 그룹 ID 숫자에 따른 동적 소비자 수를 원할 때 사용하면 좋은 모델
	- Kinesis 데이터 스트림은 예를 들어 트럭 10,000대가 많은 데이터를 전송하고 또 Kinesis 데이터 스트림에 샤드당 데이터를 정렬할 때 사용

# SQS vs SNS vs Kinesis

![kns](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/kns7.png)

- SQS, SNS, Kinesis 사이의 차이점
- SQS
	- 소비자가 SQS 대기열에서 메시지를 요청해서 데이터를 가져오는(pull) 모델
	- 따라서 데이터를 처리한 후 소비자가 대기열에서 삭제해서 다른 소비자가 읽을 수 없도록 해야함
	- 작업자나 소비자 수는 제한이 없음
		- 작업자와 소비자가 함께 소비하고 대기열에서 삭제하기 때문
	- 관리된 서비스이므로 처리량을 프로비저닝할 필요가 없음
	- 아주 빠르게 수백 수천 개의 메시지로 확장할 수 있음
	- 순서를 보장하려면 FIFO 대기열, 즉 선입선출 대기열을 활성화해야 함
	- 각 메시지에 지연 기능이 있어 30초 등 일정 시간 뒤에 대기열에 나타나도록 할 수도 있음
- SNS
	- 게시/구독 모델
		- 다수의 구독자에게 데이터를 푸시하면 메시지의 복사본을 받게됨
	- SNS 주제별로 1,250만 명의 구독자까지 가능
	- 데이터가 한 번 SNS에 전송되면 지속되지 않음
		- 즉 제대로 전달되지 않는다면 데이터를 잃을 가능성이 있음
	- 최대 10만 개의 주제로 확장 가능
	- 처리량을 프로비저닝하지 않아도 되고 원한다면 SQS와 결합할 수 있음
	- 팬아웃 아키텍처 패턴을 이용하면 SNS와 SQS를 결합하거나 SNS FIFO 주제를 SQS FIFO 대기열과 결합할 수 있음
- Kinesis
	- 두 가지 소비 모드가 있음
		- 표준 모드
			- 소비자가 Kinesis로부터 데이터를 가져옴(pull)
			- 샤드당 2 MB/s의 속도를 지원
		- 향상된 팬아웃 유형의 소비 메커니즘
			- Kinesis가 소비자에게 데이터를 푸시
			- 샤드 하나에 소비자당 2 MB/s의 속도
			- 처리량이 훨씬 높을 테니 Kinesis 스트림에서 더 많은 애플리케이션 읽기가 가능
	- Kinesis 데이터 스트림에서는 데이터가 지속되기 때문에 데이터를 다시 재생할 수 있음
		- 따라서 실시간 빅 데이터 분석, ETL 등에 활용
	- 샤드 레벨에서 정할 수 있어 미리 Kinesis 데이터 스트림마다 원하는 샤드 양을 지정해야 함
		- 샤드를 직접 확장해서 데이터가 언제 만료될지 정함
	- 1에서 365일까지 데이터를 보존할 수 있음
	- 용량 모드
		- 프로비저닝 용량 모드
			- Kinesis 데이터 스트림으로부터 원하는 샤드 양을 미리 지정
		- 온디맨드 용량 모드
			- 샤드 수가 Kinesis 데이터 스트림에 따라 자동으로 조정됨

