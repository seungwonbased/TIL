- 애플리케이션을 여러 개 배포하려고 할 때 커뮤니케이션을 할 수 밖에 없음
	- 서비스는 정보와 데이터를 공유해야 함
- 애플리케이션 커뮤니케이션은 두 가지 패턴으로 나뉘어짐
- 동기 커뮤니케이션
	-  애플리케이션이 또 다른 애플리케이션과 직접적으로 연결됨
	- 예를 들어 온라인으로 물건을 사고 파는 서비스가 있다고 했을 때, 물건이 판매가 되면 배송 서비스에 연락해서 방금 판매된 물건을 배송해야 함
	- 구매 서비스와 배송 서비스는 직접적으로 연결되어 있기 때문에 동기 커뮤니케이션이 발생하고 있음
	- 구매 서비스가 배송 서비스에게 사건이 발생했으니 배송을 하라고 얘기
- 비동기 혹은 이벤트 기반 유형
	- 대기열 등으로 불리는 미들웨어가 애플리케이션들을 연결
	- 이런 경우에는 구매 서비스가 '누군가가 어떤 물건을 구매했으니 이를 대기열에 포함시키겠다'라고 함
	- 그러면 배송 서비스가 대기열에게 최근 구매 내역이 있는지 물어봄
	- 대기열이 해당 요소를 반환하면 배송 서비스는 자기가 원하는 것을 무엇이든지 할 수 있음
	- 구매 서비스와 배송 서비스는 직접 연결되어 있지 않음
	- 그 사이에 대기열이 있을 뿐임
	- 서로 직접적으로 소통하지 않기 때문에 비동기적이라고 하는 것임
- 어플리케이션 간의 동기화는 때때로 문제가 될 수 있음
	- 구매가 갑자기 너무 증가했거나, 한 서비스가 다른 서비스를 압도하는 경우
	- 비디오 인코딩 서비스에서 평소에는 10개만 인코딩 해오고 있었다면 1,000개의 비디오를 인코딩해야 할 때
	- 서비스가 압도될 것이고 운용이 정지될 수 있음
- 트래픽이 갑자기 급증하거나 아무것도 예측할 수 없을 때 일반적으로 애플리케이션을 분리하고 분리 계층을 확장하는 것이 좋음
- 대기열 모델에는 SQS를, pub/sub 모델의 경우 SNS를, 실시간 스트리밍을 하고 대용량 데이터를 다룬다면 Kinesis로 분리할 수 있음
	- 이 세 가지를 사용하여 SQS, SNS와 Kinesis와 독립적으로 서비스를 확장할 수 있음
	- 이 세 가지는 매우 잘 확장됨

# Amazon SQS
## What's a queue?

![sqs1](https://github.com/seungwonbased/TIL/blob/main/AWS/assets/sqs1.png)

- SQS의 핵심은 Queue (대기열)
- SQS는 간단한 대기 서비스이기 때문
- SQS 대기열에는 메시지를 포함할 것임
- 메시지를 담기 위해서는 무언가 SQS 대기열에 메시지를 전송해야 하는데 SQS 대기열에 메시지를 보내는 주체를 생산자라고 함
	- 생산자는 한 개일 수도 그 이상일 수도 있음
	- 여러 생산자가 여러 개의 메시지를 SQS 대기열에 보내게 할 수 있음
- 메시지는 무엇이든 상관없음
	- '오더를 처리해라'일 수도 있고 '비디오를 처리해라'일 수도 있음
- 생성한 모든 메시지는 대기열에 들어감
	- 그런 다음 대기열에서 메시지를 처리
- 수신해야 하는 대상을 소비자라고 함
	- 소비자는 대기열에서 메시지를 폴링하는데 이는 대기열에게 소비자 앞으로 온 메시지가 있는지를 물어보는 것
	- 만일 대기열에 메시지가 있으면 소비자는 이 메시지를 폴링해서 정보를 얻음
		- 그리고 그 메시지로 처리를 하고 대기열에서 그 메시지를 삭제
	- 여러 소비자가 SQS 대기열에서 메시지를 소비할 수 있도록 할 수도 있음
- 대기열 서비스는 생산자와 소비자 사이를 분리하는 버퍼 역할


SQS는 복잡한 서비스입니다 이에 대해 자세히 살펴보겠습니다

가장 먼저 제공되는 것은 표준 대기열용 Amazon SQS입니다

SQS는 AWS에서 제공하는 가장 오래된 서비스입니다

AWS의 첫 번째 서비스 중 하나였습니다

10년이 넘었으므로 작동 방식이 확실하게 구축되어 있죠

완전 관리형 서비스이며 애플리케이션을 분리하는 데 사용됩니다

시험에서 애플리케이션 분리에 대한 문제가 보이면

Amazon SQS을 생각하시면 됩니다

그러면 SQS의 특별한 점은 무엇일까요?

무제한 처리량을 얻을 수 있다는 겁니다

즉 초당 원하는 만큼 메시지를 보낼 수 있고

대기열에도 원하는 만큼 메시지를 포함시킬 수 있습니다

처리량에 제한이 없고 대기열에 있는 메시지 수에도 제한이 없습니다

각 메시지는 수명이 짧습니다 그게 무슨 뜻일까요?

메시지는 기본값으로 4일 동안 대기열에 남아 있고

대기열에 있을 수 있는 최대 시간은 14일입니다

즉 대기열에 메시지를 보내자마자

소비자가 읽고 해당 보존 기간 내에

처리한 후 대기열에서 삭제해야 합니다

그렇지 않으면 소실됩니다

지연 시간이 짧아서 SQS는 메시지를 보내거나 SQS에서 메시지를 읽을 때마다

게시 및 수신 시 10밀리초 이내로

매우 빠르게 응답을 받게 됩니다

그리고 SQS의 메시지는 작아야 합니다

전송된 메시지당 256KB 미만이어야 합니다

SQS는 대기열 서비스이므로 높은 처리량, 높은 볼륨 등이 있어서

중복 메시지가 있을 수 있습니다

예를 들어 메시지가 두 번 전송되는 경우가 있으므로

적어도 한 번의 전송이라고 하는 겁니다

여러분이 애플리케이션을 작성하실 때

이 점을 염두에 두셔야 합니다

최선의 오더라는 뜻으로

품절 메시지를 보낼 수도 있습니다

그리고 그 제한을 처리할 수 있는 SQS의

또 다른 유형의 제품이 있긴 하지만

이 섹션의 뒷부분에서 설명하겠습니다

이제 메시지 생산자로 돌아가 보겠습니다

최대 256KB의 메시지가

생산자에 의해 SQS로 전송됩니다

어떻게 보낼까요? 생산자는 SDK 소프트웨어 개발 키트를 사용하여

SQS에 메시지를 보낼 겁니다

SQS에 메시지를 보내는 API를 SendMessage라고 합니다

매우 간단합니다 메시지가 작성되면

소비자가 해당 메시지를 읽고

삭제할 때까지 SQS 대기열에 유지됩니다 메시지가 삭제됐다는 것은

메시지가 처리됐다는 뜻이죠 저희는 보존에 대해서는 알고 있습니다

그렇다면 메시지 생성의 어떨 때 사용할까요?

예를 들어 패킷과 같은 오더를

처리한 다음 센터로 배송하려고 합니다

따라서 원하는 시간에 이 작업을 수행하여

오더 ID, 고객 ID와 원하는 속성 등의

일부 정보가 포함된 메시지를 SQS 대기열로 보냅니다

주소도 원하는 속성에 들어갈 수 있겠죠

그러면 애플리케이션 권한에 있는

소비자는 해당 메시지 자체를 처리해야 합니다

말씀드렸듯 표준 SQS는 무제한 처리량을 자랑하죠

생산자에 대해 살펴보았습니다 매우 간단합니다

이제 소비자에 대해 살펴보겠습니다

소비자는 일부 코드로 작성해야 하는

애플리케이션이고

이러한 애플리케이션은 EC2 인스턴스

즉 AWS 상의 가상 서버에서 실행될 수 있습니다

원하는 경우 자체 온프레미스 서버에서 실행할 수도 있고

아직 배우지는 않았지만

AWS Lambda의 람다 함수에서 실행할 수도 있습니다

이 강의에서 배우겠지만 서버가 없는 컴퓨터 유형의 서비스입니다

이는 람다에서 메세지를 바로 읽을 수도 있다는 것을 의미합니다

이 내용은 이후에 배울 것이니 걱정하지 마세요

EC2 인스턴스에 대한 간단한 사용 사례로 돌아가 보면

대기열에는 소비가가 있고 소비자는 SQS 메시지를 폴링합니다

즉 소비자가 대기열에 자신의 앞으로 온 메시지가 있는지를

묻습니다

그리고 소비자는 아마 한 번에 최대 10개의 메세지를 받을 겁니다

SQS 대기열에 메세지가 있으면

'여기 너를 기다리는 메세지가 있어'라는 유효한 응답을 받을 겁니다

여러분의 코드인 소비자는

이 메시지들을 처리할 책임이 있습니다

RDS 데이터베이스에 오더를 입력하는 경우를 생각해 보죠

즉 각 오더들을 RDS 데이터베이스에

삽입하면

물론 이 작업은 코딩으로 이루어지겠죠

그렇게 삽입하면 이 메시지들이 수신되어

처리됐기 때문에

Amazon RDS 데이터베이스로 삽입됩니다

그러면 소비자가 이 메시지들을 DeleteMessage API로

대기열에서 삭제합니다

그러면 다른 소비자들이

이 메세지를 볼 수 없게 되겠죠

그러면 메시지 처리가 완료됩니다

이를 확장해 보면 여러 소비자를 동시에 가질 수 있습니다

SQS 대기열은 메세지를 동시에

수신하고 처리할 소비자를 여러 개 가질 수 있습니다

여기 EC2 인스턴스 세가지가 있고

각 소비자는 poll 함수를 호출하여

다른 메시지 세트를 수신하게 됩니다

만일 메시지가 소비자에 의해 충분히 빠르게 처리되지 않으면

다른 소비자가 수신하게 됩니다

그래서 적어도 한번은 전송이 된다고 하는 겁니다

그리고 이것이 최선의 노력으로 메시지 순서 지정을 하는 이유입니다

말씀드렸듯 소비자가 메시지를 처리하면 메시지를 삭제해야 합니다

그렇지 않으면 다른 소비자가 메시지를 보게 되겠죠

SQS 대기열에서

더 많은 메시지가 있어서 처리량을 늘려야 하면

소비자를 추가하고 수평 확장을 수행해서

처리량을 개선할 수 있습니다

이전에 배운 것들을 기억하신다면

이건 ASG (Auto Scaling groups)와 더불어

SQS를 사용하는 완벽한 사례입니다

그게 무슨 뜻일까요? 소비자가 ASG의 내부에서

EC2 인스턴스를 실행하고

SQS 대기열에서 메시지를 폴링할 것이라는 겁니다

ASG는 일종의 지표에 따라 확장되어야 하는데

저희가 사용할 수 있는 지표는 대기열의 길이입니다

ApproximateNumberOfMessages라고 합니다

이는 모든 SQS 대기열에서 쓸 수 있는 CloudWatch 지표입니다

알람을 설정할 수도 있는데 대기열의 길이가 특정 수준을 넘어가면

CloudWatch Alarm을 설정하세요

이 알람은 오토 스케일링 그룹의 용량을

X만큼 증가시킵니다

그러면 더 많은 메시지가 SQS 대기열에 있게 됩니다

만일 웹사이트에 오더가 폭주했다거나 해서

오토 스케일링 그룹이 더 많은 EC2 인스턴스를 제공하면

메시지들을 더 높은 처리량으로 처리할 수 있습니다

이는 일반적인 통합으로 시험에 흔히 출제됩니다

SQS는 애플리케이션 계층 간에

분리를 위해 사용됩니다

가령 비디오를 처리하는

애플리케이션이 있다고 해보겠습니다

프론트엔드라는 큰 애플리케이션이 있는데, 프론트엔드가 요청을 받고

비디오가 처리되어야 할 때

프론트엔드가 처리를 한 후 S3 버킷에 삽입합니다

하지만 문제는 처리 시간이 매우 오래 걸릴 수 있고

프론트엔드에서 이를 처리하면

웹사이트의 속도가 느려질 수 있다는 겁니다

대신 애플리케이션을 분리하여

파일 처리 요청과 실제 파일 처리가

서로 다른 애플리케이션에서

발생할 수 있도록 할 수 있습니다

파일 처리 요청을 받을 때마다

SQS 대기열로 메시지를 전송하는 거죠

그러면 처리 요청을 할 때

해당 파일은 SQS 대기열에 있게 됩니다

자체 오토 스케일링 그룹에 속할

백엔드 처리 애플리케이션이라는

두 번째 처리 계층을 생성할 수 있습니다

이 애플리케이션이 메시지를 수신하고 비디오를 처리하고

S3 버킷에 이를 삽입할 겁니다

여기 이 아키텍처에서 볼 수 있듯이

그에 따라 프론트엔드를 확장할 수 있고

그에 따라 백엔드도 확장할 수 있지만 독립적으로 확장할 수 있습니다

SQS 대기열은 처리량이 무제한이고

대기열 측면에서 메시지 수에 제한이 없기 때문에

정말 안전합니다

이는 강력하고 확장 가능한 유형의 아키텍처입니다

또한 프론트엔드의 경우 최적의 유형의 EC2 인스턴스 또는 아키텍처를

프론트엔드에 사용할 수 있습니다 백엔드의 경우

비디오 처리를 수행할 때 그래픽 처리 장치인 GPU가 있는 일부

EC2 인스턴스를 사용할 수 있습니다

이러한 유형의 인스턴스가

워크로드를 수행하는 데에 최적이기 때문입니다

이것이 시험에 나올 것으로 예상되는 아키텍처 유형이며

탁월하고 효과적인 SQS 대기열

사용 사례를 살펴봤습니다

마지막으로 SQS 보안입니다 HTTPS API를 사용하여

메시지를 보내고 생성함으로써 비행 중 암호화를 하고

KMS 키를 사용하여 미사용 암호화를 얻고

원한다면 클라이언트 측 암호화를 할 수도 있는데

이는 클라이언트가 자체적으로 암호화 및 암호 해독을 수행해야 함을 의미합니다

SQS에서 기본적으로 지원하는 것은 아닙니다

액세스 제어를 위해 IAM 정책은

SQS API에 대한 액세스를 규제할 수 있고

S3 버킷 정책과 유사한

SQS 액세스 정책도 있습니다

SQS 대기열에 대한 교차 계정 액세스를

수행하려는 경우나

곧 배울 SNS 혹은 Amazon S3 같은

다른 서비스가 SQS 대기열에 S3 이벤트 같은 것을 쓸 수 있도록

허용하려는 경우에 매우 유용합니다

SQS에 대한 개요는 여기까지입니다 마음에 드셨길 바라며

다음 강의에 뵙겠습니다