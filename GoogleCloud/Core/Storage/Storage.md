# Cloud Storage

![cst](https://github.com/seungwonbased/TIL/blob/main/GoogleCloud/assets/cst1.png)

# Cloud Storage

- Google Cloud의 객체 스토리지 서비스
- 데이터 양에 상관없이 언제 어디서나 데이터를 저장하고 가져올 수 있음
- 예시
    - 웹 사이트 콘텐츠 제공
    - 보관 처리
    - 재해 복구를 위한 데이터 저장
    - 직접 다운로드를 통해 사용자에게 대량의 데이터 객체 배포
    - 등등

## 주요 기능

- 엑사바이트 규모의 데이터로 확장 가능
- 첫 바이트 소요 시간은 밀리초 단위
- 모든 스토리지 클래스에서 고가용성 지원
- 해당 스토리지 클래스 전체에 단일 API 지원

## 구조

- Cloud Storage는 객체를 배치하는 Bucket의 모음
    - 파일 시스템 내의 파일이 아님
    - 디렉터리를 만들 수는 있지만 디렉터리는 버킷의 또 다른 객체를 가리키는 객체일 뿐
- 특정 URL로 객체에 액세스 가능
    - 파일 시스템처럼 모든 파일에 인덱스로 접근하지 않음

## Storage Class

- 모든 객체에 적용되는 메타데이터의 조각
- 스토리지 클래스는 객체의 가용성 및 가격 책정 모델에 영향

![cst](https://github.com/seungwonbased/TIL/blob/main/GoogleCloud/assets/cst2.png)

### 위치 유형

- 각 스토리지 클래스는 3가지 위치 유형 제공
    - Multi region: 두 개 이상의 지리적 장소를 포함하는 넓은 지리적 지역 (예: US)
        - 리전보다 높은 가용성
        - 리전 전반에 걸친 데이터 중복 (비동기)
        - 리전보단 높지만 이중 리전보단 낮은 가격
        - 복제 요금 발생
    - Dual region: 특정한 리전의 쌍 (예: 도쿄, 오사카)
        - 리전보다 높은 가용성
        - 리전 전반에 걸친 데이터 중복 (비동기)
        - 가장 비싼 가격
        - 복제 요금 발생
    - Region: 특정한 지리적 장소 (예: 상파울루)
        - 가용 영역 전반에 걸친 데이터 중복 (동기)
        - 최저 스토리지 가격
        - 복제 요금 없음
- 멀티 리전이나 이중 리전에 저장된 객체는 **지리적 중복**
    - 지리적으로 중복된 객체는 최소 161km 이상 떨어진 지리적 장소 최소 두 곳에 중복 저장됨

![cst](https://github.com/seungwonbased/TIL/blob/main/GoogleCloud/assets/cst3.png)

### Standard Storage

- 핫 데이터처럼 액세스 빈도가 높거나 짧은 기간만 저장되는 데이터에 가장 적합
- 가장 비싼 스토리지 클래스에 해당되지만 최소 저장 기간이 없고 검색 비용이 없음
- Region에 사용되는 경우
    - 데이터를 사용하는 GKE 클러스터나 Compute Engine 인스턴스와 동일한 곳에 데이터를 저장할 때 적합
        - 리소스를 같은 곳에 배치하면 데이터 집약적인 계산의 성능을 극대화하고 네트워크 비용을 줄일 수 있음
- Dual region에 사용되는 경우
    - 연결된 리전 중 하나에 위치한 Google Cloud 제품에 액세스할 때 성능이 최적화
    - 지리적으로 별도의 위치에 데이터를 저장하는 경우 가용성 향상
- Multi region에 사용되는 경우
    - 전세계에서 자주 액세스되는 데이터를 저장하는 데 적합
    - 웹 사이트 콘텐츠, 동영상 스트리밍, 대화형 워크로드, 모바일 및 게임 애플리케이션 등

### Nearline Storage

- 비용이 저렴하고 내구성이 높음
- 데이터 백업, 롱테일 멀티미디어 콘텐츠, 데이터 보관처리와 같이 액세스 빈도가 낮은 데이터 저장에 유리
- 스토리지 비용을 줄이기 위해 조금은 낮은 가용성, 30일의 최소 저장 기간, 높은 데이터 액세스 비용을 용인할 수 있다면 Standard보다 나은 선택

### Coldline Storage

- 비용이 매우 저렴하고 내구성이 높음
- 자주 액세스하지 않는 데이터를 저장
- 낮은 가용성, 90일의 최소 저장기간, 더 높은 데이터 액세스 비용을 용인할 수 있다면 Standard, Nearline보다 나은 선택

### Archive Storage

- 가장 저렴하고 내구성이 높음
- 데이터 보관 처리, 온라인 백업, 재해 복구에 사용
- 다른 클라우드 공급 업체에서 제공하는 ‘콜드’ 스토리지 서비스와 달리 데이터가 몇 시간 또는 며칠이 아닌 밀리초 이내에 제공됨
- 가용성 SLA가 없음
    - 그러나 일반적인 가용성은 Nearline 및 Coldline Storage와 비슷한 수준
- 데이터 액세스 및 운영 비용이 상대적으로 높으며 최소 저장 기간도 365일
- 일 년에 한 번 미만으로 액세스하려는 데이터에 적합

### 내구성과 가용성

- 내구성
    - 모든 스토리지 클래스의 내구성은 99.999999999%
        - 데이터가 손실되지 않는다는 뜻
- 가용성
    - 데이터의 접근 가능성이나 이용 가능성
    - 스토리지 클래스와 위치 유형에 따라 다름

## Cloud Storage를 나눌 수 있는 항목

### Bucket

- 여러 개의 객체가 저장될 수 있음
- 전역적으로 고유한 이름이 필요
- 버킷 중첩 (nested) 불가능
    - 버킷은 단순한 키/값 저장소로 버킷은 폴더와 같은 논리적인 개념은 제공하지만 버킷 내의 또 다른 버킷을 생성하거나 중첩하는 것은 불가능

### Object

- 버킷에 들어가는 데이터는 버킷의 스토리지 클래스를 상속하는 객체
- 객체는 텍스트 파일, 문서 파일, 동영상 파일 등이 될 수 있음
- 객체에는 최소 크기가 없으며 할당량이 허용하는 한 원하는 만큼 확장 가능

### Access

- 데이터에 액세스하려면 gsutil 명령어를 사용하거나 JSON 또는 XML API 사용

## Default 스토리지 클래스 변경

- 버킷에 객체를 업로드할 때 객체의 스토리지 클래스를 지정하지 않으면 버킷의 스토리지 클래스가 객체에 할당됨
- 버킷의 기본 스토리지 클래스를 변경할 수 있음
    - 이미 버킷에 있는 객체의 스토리지 클래스를 변경할 수도 있음
        - 객체를 다른 버킷으로 이동하거나 객체의 URL을 변경하지 않고도 가능
- 위치 유형은 변경할 수 없음
- 객체는 버킷에서 버킷으로 옮길 수 있음
- Cloud Storage는 버킷의 객체 클래스를 관리할 수 있도록 객체 수명 주기 관리를 제공

## Access control

![cst](https://github.com/seungwonbased/TIL/blob/main/GoogleCloud/assets/cst4.png)

- 프로젝트에 IAM을 사용해 개별 사용자 또는 서비스 계정이 버킷을 보고, 버킷의 객체를 나열하고, 버킷에 있는 객체의 이름을 보고, 새 버킷을 생성할 수 있는 권한을 제어 가능
- 대부분의 경우 Cloud IAM으로 충분
- 역할은 프로젝트에서 버킷, 객체로 상속됨
- ACLs(Access Control Lists)은 더 세밀한 제어 제공
- 세부적으로 제어가 가능한 서명된 URL은 암호화 키를 제공
    - 암호화 키는 버킷 또는 객체에 대한 액세스 시간을 제한
- 서명된 정책 문서는 서명된 URL이 있는 사람이 업로드할 수 있는 파일의 종류를 정하는 방식
    - 더욱 정교한 제어 가능

### ACLs (Access Control Lists)

![cst](https://github.com/seungwonbased/TIL/blob/main/GoogleCloud/assets/cst4.png)

- 버킷 및 객체에 액세스할 수 있는 사용자와 그 사용자에게 제공할 액세스 권한 수준을 정의하는 데 사용하는 매커니즘
- 버킷이나 객체마다 최대 100개의 ACL 항목을 만들 수 있음
- 각 ACL은 하나 이상의 항목으로 이뤄짐
    - 항목은 두 가지 정보로 구성
        - 범위: 지정된 작업을 수행할 수 있는 사람을 정의 (예: 특정 사용자, 사용자 그룹)
        - 권한: 수행할 수 있는 작업을 정의 (예: 읽기, 쓰기)

### 서명된 URL

- 일부 애플리케이션의 경우 리소스 액세스를 제어하는 데 계정 기반 인증을 사용하는 것보다 모든 사용자가 사용할 수 있는 시간이 제한된 액세스 토큰을 부여하는 게 쉽고 더 효율적
    - 예: 사용자가 Google 계정을 요구하지 않으려는 경우
- 특정 Cloud Storage 리소스에 대한 읽기 또는 쓰기 액세스 권한을 부여하고 액세스 만료 시기를 지정하는 URL을 생성, 해당 URL은 서비스 계정과 연결된 비공개 키를 사용해 서명됨
- 요청이 수신되면 Cloud Strorage는 액세스 권한 부여 URL이 신뢰할 수 있는 보안 주체를 대신해 발급되었는지 확인 (서비스 계정이 보안 주체)
- 그 다음 해당 계정의 신뢰를 URL 소유자에게 위임
- 서명된 URL을 제공한 후에는 제어할 수 없으므로 적절한 시간이 지나면 서명된 URL이 만료되도록 설정하는 것이 좋음

# Cloud Storage의 기능

## Customer-supplied encryption key (CSEK)

- Google이 관리하는 키 대신 자체 암호화 키 제공 가능

## 객체 수명 주기 관리

- 객체를 자동으로 삭제하거나 보관처리 가능
- 수명 주기 관리 구성을 버킷에 할당 가능
    - 구성은 버킷의 모든 객체에 적용되는 규칙 집합
- 예시
    1. 일 년 이상 된 객체의 스토리지 클래스를 Coldline Storage에 다운그레이드
    2. 특정 날짜 이전에 생성된 객체를 삭제
    3. 버전 관리가 사용 설정된 상태에서는 버킷 내 각 객체에 대해 가장 최근의 3개 버전만 유지
- 객체 검사는 비동기식 배치에서 발생하므로 규칙이 즉시 적용되지 않을 수 있음
- 수명 주기 구성의 업데이트가 반영되기까지 최대 24시간이 걸릴 수 있음
    - 즉, 수명 주기 구성을 변경할 때 최대 24시간 동안 여전히 이전 구성으로 작업을 수행할 수도 있다는 뜻

## Object versioning

- 여러 버전의 객체를 유지관리 할 수 있는 기능
- 여러 개의 파일처럼 여러 버전에 대해 요금 부과
- Cloud Storage에서 객체는 변경 불가능
    - 스토리지 수명 주기 동안 업로드한 객체를 변경할 수 없음
- 삭제하거나 덮어쓴 객체를 검색할 수 있도록 객체 버전 관리 기능을 제공
- 버킷에 대해 객체 버전 관리 기능을 사용 설정할 수 있음
- 사용 설정되면 객체의 실시간 버전을 덮어쓰거나 삭제할 때마다 Cloud Storage가 보관 처리된 객체 버전을 만듬
    - 보관 처리된 버전의 객체 이름은 유지되지만 g1과 같은 세대 번호로 고유하게 식별됨
- 객체 버전 관리를 사용 설정하면 객체의 보관 처리된 버전을 나열하거나, 객체의 실시간 버전을 이전 상태로 복원하거나, 필요에 따라 보관 처리된 버전을 영구 삭제할 수 있음
- 버전 관리를 중지하면 기존 객체 버전은 남지만 버킷이 보관 처리된 새로운 객체 버전을 더 이상 축적하지 않음

## Directory synchronization

- VM 디렉터리를 버킷과 동기화할 수 있는 기능

## Object change notification

![cst](https://github.com/seungwonbased/TIL/blob/main/GoogleCloud/assets/cst5.png)

- 감시 요청을 하면 객체가 업데이트 되거나 버킷에 추가될 때 이를 애플리케이션에 알리는 데 객체 변경 알림이 사용됨
- 감시 요청을 완료하면 새 알림 채널이 만들어짐
- 알림 채널을 통해 버킷을 감시하는 애플리케이션 알림 메시지가 전송됨
- 아직까지 지원하는 유일한 알림 채널은 Webhook
- 알림 채널이 시작되면 Cloud Storage는 객체가 추가, 업데이트, 제거될 때마다 이를 애플리케이션에 알림
- 위 사진 예시
    - 버킷에 새 그림이 추가되면 애플리케이션은 썸네일을 만들라는 알림을 받을 수 있음
- Pub/Sub 알림은 Cloud Storage 버킷 내 객체 변경사항을 추적하는 데 권장되는 방법
    - 빠르고 유연하며 설정하기 쉽고 경제적이기 때문
    - Pub/Sub은 분산형 실시간 메시지 서비스

## Data import

- Cloud Console을 사용해 버킷에 개별 파일 업로드 가능
    - 하지만 테라바이트, 페타바이트급 데이터 업로드라면?
        - 아래 세 가지 서비스 이용

### Transfer Appliance

![cst](https://github.com/seungwonbased/TIL/blob/main/GoogleCloud/assets/cst6.png)

- 비즈니스 운영을 중단하지 않고도 수백 테라바이트에서 최대 1 페타바이트의 대량 데이터를 Google Cloud로 안전하게 마이그레이션하는 하드웨어 어플라이언스

### Storage Transfer Service

- 온라인 데이터를 고성능으로 가져올 수 있음
- 데이터 소스는 다른 Cloud Storage 버킷이나 Amazon S3 버킷, HTTP/HTTPS 위치일 수 있음

### 오프라인 미디어 가져오기

- 스토리지 어레이, 하드 디스크 드라이브, 테이프 및 USB 플래시 드라이브와 같은 물리적 매체를 타사 제공업체에 전달하면 해당 업체에서 데이터를 업로드하는 서비스

## Strong consistency

- 업로드의 Strong consistency
    - Cloud Storage에 객체를 업로드하고 성공 응답을 받으면 Google이 서비스를 제공하는 모든 위치에서 객체를 즉시 다운로드하고 메타데이터 작업에 사용 가능
    - 새로운 객체를 만들거나 기존 객체를 덮어쓸 때도 마찬가지
    - 쓰기 후 읽기 또는 메타데이터 업데이트 후 읽기 작업에 대해 404 Not Found 응답이나 비활성 데이터를 수신하는 일이 절대로 없음
- 삭제 작업의 Strong consistency
    - 삭제 요청이 성공한 경우 객체 또는 객체의 메타데이터를 바로 다운로드하려고 시도하면 404 Not Found 상태 코드가 반환됨
- 버킷 나열도 Strong consistency를 가짐
    - 버킷을 만든 후 버킷 나열 작업을 즉시 수행하면 반환된 버킷 목록에 새로운 버킷이 나타남
- 객체 나열 또한 Strong consistency를 가짐
    - 객체를 버킷에 업로드한 후 객체 나열 작업을 즉시 수행하면 반환된 객체 목록에 새로운 객체가 나타남

# Cloud Storage Class 결정 트리

![cst](https://github.com/seungwonbased/TIL/blob/main/GoogleCloud/assets/cst7.png)

## Storage Class

1. 데이터를 1년에 한 번 미만으로 읽는 경우 Archive Storage 사용을 고려하는 것이 좋음
2. 데이터를 90일에 한 번 미만으로 읽는 경우 Coldline Storage 사용을 고려하는 것이 좋음
3. 데이터를 30일에 한 번 미만으로 읽는 경우 Nearline Storage 사용을 고려하는 것이 좋음
4. 이보다 읽기, 쓰기를 더 자주 수행할 경우 Standard Storage 사용을 고려하는 것이 좋음

## Location Type

- Region을 사용하면 동일한 리전에서 그룹화된 분석 파이프라인과 같은 데이터 소비자의 지연 시간과 네트워크 대역폭을 최적화할 수 있음
- Dual region은 리전과 유사한 성능 이점과 함께 지리적 중복을 통해 제공되는 더 높은 가용성을 원하는 경우 사용
- Multi region은 Google 네트워크 외부에 있거나 넓은 지리적 지역에 분산되어 있는 데이터 소비자에게 콘텐츠를 제공하려는 경우 또는 지리적 중복을 통해 제공되는 더 높은 데이터 가용성을 원하는 경우에 사용