# CSRF (Cross-Site Request Forgery)

- 사이트 간 요청 위조
- 인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격
- 공격자가 희생자의 컴퓨터를 감염시키거나 어떤 서버를 해킹해서 이뤄지는 공격은 아님

## CSRF 공격이 이뤄지기 위한 조건

1. 희생자가 로그인한 웹 애플리케이션
	- 공격자가 CSRF를 실행하려면 희생자가 웹 애플리케이션에 로그인되어 있어야 함
		- 로그인되지 않은 상태에서는 공격자가 사용자의 권한을 이용할 수 없음
	- 예시: Alice라는 사용자가 은행 웹 애플리케이션에 로그인되어 있음
2. 공격자가 악의적인 웹 페이지를 가지고 있거나 생성할 수 있는 능력
	- 공격자는 희생자에게 특정 악의적인 웹 페이지에 접근하거나 이를 생성할 수 있어야 함
		- 이 페이지는 CSRF 공격을 실행하는데 사용됨
	- 예시: 공격자가 악의적인 웹 페이지를 생성하고 이를 공유할 수 있는 능력을 가지고 있음
3. 희생자가 공격자의 웹 페이지에 접근하거나 공격자의 페이지를 열게 되는 행동
	- 희생자는 공격자의 페이지에 접근하거나 이를 열어야 함
		- 이때, 희생자는 공격에 대한 경각심이나 의심이 없어야 함
	- 예시: Alice가 공격자의 웹 페이지를 열거나 공격자가 이 페이지를 열도록 속임
4. 악의적인 요청을 실행하는 스크립트나 코드
	- 공격자가 희생자의 권한으로 웹 애플리케이션에 악의적인 요청을 보내야 함
		- 이를 위해 공격자는 CSRF 스크립트나 코드를 희생자의 브라우저에서 실행시켜야 함
	- 예시: 공격자가 악의적인 요청을 실행하는 HTML 및 JavaScript 코드를 희생자의 브라우저에서 실행시킴
5. 악의적인 요청의 유효성 확인 없음
	- 웹 애플리케이션은 요청이 유효하고 허가된 것인지 확인하는 보안 메커니즘을 구현하지 않았거나, 이를 우회할 수 있는 경우에 공격이 성공할 가능성이 높아짐
	- 예시: 웹 애플리케이션이 CSRF 토큰을 사용하지 않거나, 토큰을 검증하지 않는 경우
-  이러한 조건이 충족되면, 공격자는 희생자의 권한으로 악의적인 작업을 수행할 수 있으며, 이것이 CSRF 공격

## CSRF 방어 기법

1. CSRF 토큰 사용
	- 웹 애플리케이션은 사용자 세션과 연관된 고유한 CSRF 토큰을 생성
		- 이 토큰은 모든 중요한 요청에 함께 포함되어야 함
	- 서버는 요청을 받을 때, 토큰의 유효성을 검증하여 CSRF 공격을 방지
2. SameSite 쿠키 속성 설정
	- SameSite 쿠키 속성을 설정하여 쿠키를 다른 도메인으로 전송하지 않도록 함
		- 이렇게 하면 공격자가 희생자의 브라우저에서 쿠키를 가져와 CSRF 공격을 실행하는 것이 어려워짐
3. Referrer 검증
	- 서버는 HTTP Referrer 헤더를 사용하여 요청이 특정 웹 페이지에서 시작되었는지 확인
		- 이 방식은 추가적인 보안 계층을 제공하지만 모든 브라우저에서 지원되지 않을 수 있음
4. 민감한 작업에 대한 추가 확인
    - 민감한 작업(예: 계정 정보 변경, 금전 이체 등)을 수행하기 전에 사용자에게 비밀번호 또는 다른 인증 요소를 요구
	    - 이렇게 하면 CSRF 공격자가 사용자의 계정에 접근해도 추가 인증 단계를 통과해야 하므로 공격이 어려워짐
5. HTTP Method 검증
	- 서버는 요청의 HTTP 메서드를 확인하여, 민감한 작업에는 POST 또는 PUT과 같은 안전한 메서드만 허용
		- GET 요청은 민감한 작업에 사용되지 않도록 해야 함
6. CORS (Cross-Origin Resource Sharing) 설정
	- 웹 애플리케이션은 필요한 경우 CORS 설정을 사용하여 다른 도메인에서의 요청을 제어하고 허용할 Origin를 지정
7. Content Security Policy (CSP)
	- CSP를 사용하여 웹 페이지에서 특정 Origin에서 리소스를 로드할 수 있는지를 제어
		- 이를 통해 외부 Origin에서의 스크립트 실행을 방지할 수 있음
8. 더 많은 로그 및 감사
	- 서버 및 애플리케이션에서 발생한 모든 요청과 작업을 기록하고 감사
		- 이러한 로그를 통해 CSRF 공격 발생 여부를 식별하고 대응할 수 있음

# SOP (Same Origin Policy)

- 동일 출처 정책
- 브라우저의 토큰이나 쿠키와 같이 사용자의 정보와 관련된 데이터의 탈취를 막기 위해 생긴 정책
	- 브라우저단에서 제한
- 예를 들어, "https://www.example.com" 에서 요청을 보낸다면 서버는 동일한 URL로만 응답을 보낼 수 있음
- 동일 출처는 프로토콜, 호스트, 포트의 동일 여부로 판단됨
	- 쿼리 스트링은 달라도 괜찮음
- 개발자는 CORS와 같은 메커니즘을 사용하여 데이터 공유를 안전하게 구현할 수 있음

## SOP 주요 원칙

1. 동일 Origin에서만 실행
	- 웹 페이지 내에서 실행되는 스크립트나 리소스는 해당 웹 페이지와 동일한 Origin에서 로드되어야 함
	- 다른 Origin에서 로드된 스크립트가 현재 웹 페이지의 데이터에 접근하거나 조작하는 것을 방지하기 위함
2. Origin 간 데이터 공유 제한
	- SOP는 웹 페이지 간 데이터 공유를 엄격히 제한
	- 다른 Origin에서 로드된 웹 페이지의 스크립트는 일반적으로 현재 웹 페이지의 데이터에 직접 접근할 수 없음
	- 이러한 액세스를 제한하는 것은 정보 누출과 크로스 사이트 스크립팅(XSS) 공격을 방지하는 데 중요

## SOP 적용

- 웹 사이트에 비디오나 사진, 혹은 다른 웹 사이트로 링크를 걸기도 함
	- 그럼 이런 건 SOP에 영향을 안 미치는 것인지?
- **Cross Origin Writes**
	- 쓰기는 보통 허용됨
	- 링크나 redirect, form 제출 등에 있어서 자유롭지만, 일부 웹 사이트에서 Preflight를 요청하기도 함
- **Cross Origin Inserts**
	- 삽입은 보통 허용됨
	- iframe이나 video, img, embed 등의 태그로 외부 리소스를 삽입
- **Cross Origin Reads**
	- 읽기는 불허하지만 CORS를 이용해 접근을 허용할 수 있음

# CORS (Cross-Origin Resource Sharing)

- 교차 출처 리소스 공유
- 웹 브라우저에서 실행되는 JS 코드가 다른 도메인(다른 Origin)의 리소스에 접근할 수 있도록 해주는 보안 매커니즘
- 일반적으로 웹 브라우저에서는 같은 출처(Origin)에 속한 웹 페이지만 다루고, 다른 출처의 리소스에 대한 접근은 브라우저에서 제한됨
	- CORS를 사용하면 웹 애플리케이션이 다른 Origin의 리소스에 대한 요청을 보내고 응답을 받을 수 있음

## CORS 주요 개념

- Origin
	- 프로토콜, 호스트, 포트로 정의됨
	- 예를 들어, "https://www.example.com" 과 "https://api.example.com" 은 서로 다른 Origin
- 요청과 응답 헤더
	- CORS는 HTTP 요청과 응답 헤더를 사용하여 동작
	- 중요한 헤더
		- Origin
		- Access-Control-Allow-Origin
		- Access-Control-Allow-Methods
		- Access-Control-Allow-Headers
		- Access-Control-Allow-Credentials
		- 등등

## CORS 요청 방식
### Simple Requests

- 다음과 같은 조건을 만족하면 브라우저는 해당 CORS 요청을 Simple Request로 처리
	- HTTP Method가 GET, POST, HEAD 중 하나인 경우
	- Content-Type 헤더가 다음 중 하나인 경우
		- application/x-www-form-urlencoded
		- multipart/form-data
		- text/plain
	- CORS-safelisted request-header를 포함하는 경우 (Fetch spec)
	- XMLHttpRequest.upload 에 이벤트 핸들러, 리스너가 등록되지 않은 경우
	- ReadableStream 객체가 포함되지 않은 경우
- 동작 방식
	1. 사용자가 요청 헤더에 자신의 Origin을 실어서 서버로 요청을 보냄
	2. 서버는 요청 헤더의 Origin을 확인
	3. CORS 요청이 유효하다면 서버는 응답 헤더에 **Accecss-Control-Allow-Origin** 헤더를 추가해 사용자에게 다시 전송
		- 유효하지 않다면 브라우저는 해당 응답을 허용하지 않고 CORS 에러를 반환

### Preflight Requests

- Simple Request의 조건을 만족하지 못할 시 브라우저가 자동으로 생성
- Simple Request와 달리 OPTIONS 메서드를 통해 다른 Origin의 리소스로 HTTP 요청을 미리 보내 (Preflight) 실제 요청이 전송하기에 안전한지 확인
- 브라우저가 안전하다고 판단하면 실제 요청을 보내게 됨
- 동작 방식
	1. 사용자가 요청을 보낼 때 Access-Control-Request- ... 와 같은 헤더에 어떤 메서드와 어떤 Content-Type으로 서버에 요청을 보낼 건지와 같은 정보를 작성함
	2. 브라우저가 서버의 응답을 허용하기 위해 서버는 앞서 작성한 헤더에 담긴 정보를 허용한다는 헤더로 응답
	3. 브라우저는 안전하다고 판단하면 실제 요청을 보냄 (실제 데이터를 담아)
	4. 서버는 응답 헤더에 Access-Control-Allow-Origin 헤더를 실어 보내고 브라우저는 Access-Control-Allow-Origin 헤더를 읽고 응답의 허용 여부를 결정

# XSS (Cross Site Scripting)

- 클라이언트에 대한 취약점을 이용해서 JS, HTML 등을 이용하고 있는 불특정 다수를 공격할 수 있음
- 공격자가 악의적인 스크립트를 사용자의 웹 브라우저에 숨겨놓게 되면 해당 사용자가 접속할 때 악성 코드가 실행됨
	- 사용자의 쿠키, 개인정보가 전송될 수 있음

## XSS 종류
### Stored XSS

- 공격자가 댓글, 게시글, 쪽지와 같은 여러 곳에 자바스크립트 코드를 숨겨 놓음
	- \<script> ... \</script>
- 사용자가 해당 웹 페이지를 열 때 숨겨진 스크립트가 실행되어 공격 당함

### Reflected XSS

- 실행 시킨 웹 페이지에서 자바스크립트 코드가 발생하고, GET 방식으로 URL에 코드 입력
- URL이 너무 길면 수상하므로 Shorten URL로 스크립트 부분이나 파라미터로 숨길 수 있음
- URL 안에 스크립트 코드 작성 시에 브라우저에서 자동으로 XSS 공격을 방지
- 피싱 웹 사이트의 원리임
	- 스트립팅을 한 URL을 뿌리고, 사용자가 페이지를 열면 스크립트가 실행되어 쿠키, 개인정보가 유출됨
- 예시: ID 중복 체크
	- ID: abc\<script> ... \</script> -> 중복 체크
	- abc\<script> ... \</script>를 사용할 수 있습니다.
		- 스크립트 실행됨

### Dom XSS

- 개발자가 만든 스크립트 코드의 취약점을 이용한 공격
- 악의적인 스크립트가 포함된 URL을 사용자가 요청하게 되어 브라우저를 해석하는 단계에 발생하는 공격
- URL과 함께 \# 이라는 특수 문자를 사용하고 있기 때문에 감지가 어려움
	- \# 이후의 값이 서버로 전송되지 않는다는 점을 이용
- 예시: https://www.example.com# \<script> ... \</script>

# CSP (Content Security Policy)

- XSS와 데이터 주입 공격을 비롯한 특정 유형의 공격을 탐지하고 완화하는 데 도움이 되는 브라우저 차원의 추가 보안 계층
- 서버에서 주로 Content-Security-Policy 헤더에 정책을 작성해서 브라우저로 내려줌
- 웹 페이지 내에서 불러오는 리소스들의 제한을 조절하는 매커니즘
	- 주로 Cross-Origin Scripting을 제한
- 완전히 막는 방법은 아니며, 예방 차원임

# 파일 업로드 취약점

- 파일의 크기나 개수를 제한하지 않음
	- 불필요하게 크거나 많은 파일을 업로드해서 서버의 연결 자원 및 디스크 자원 고갈
		- 정상적인 서비스 방해 (DDoS)
- 파일의 확장자를 제한하지 않음
	- 악성 코드가 포함된 파일이 업로드될 수 있음
		- 서버 사이드에서 실행되는 악성 코드인 경우 해당 서버의 제어권을 탈취할 수 있음 (e.g., Web Shell)
		- 클라이언트 사이드에서 실행되는 파일인 경우 해당 서버는 악성 코드 유포지로 악용될 수 있음
- 외부에서 접근 가능한 경로에 파일을 저장
	- 서버 사이드에 악성 코드를 심을 수 있음
	- 웹 루트 밖에 있는 디렉터리에 파일을 저장하도록 하고, 불러올 때는 \<img src="download?file:...">과 같은 **다운로드 기능**을 구현해야 함
