# 마이크로 서비스에 대한 서비스 간 통신 설계

## 1. 개요

> 참고 문헌: Nginx 블로그, Microsoft Azure 공식 문서

- 모놀리식 애플리케이션에서 구성 요소는 언어 수준, 즉 Method 또는 함수 호출을 통해 서로와 통신
- 이와 대조적으로 MSA 기반 애플리케이션은 여러 시스템에서 실행되는 분산 시스템
- 각 서비스 인스턴스는 일반적으로 프로세스임
	- 프로세스는 완전히 독립된 실행 객체
		- 독립되어 있다는 것은 다른 프로세스의 영향을 받지 않는다는 것
	- 따라서 각 서비스는 IPC (프로세스 간 통신) 매커니즘을 사용해 상호 작용

> 간단히 IPC의 여러 종류에 대해 소개

### 1.1. IPC의 여러 종류

- Anonymous PIPE
	- 통신을 할 프로세스를 명확하게 알 수 있는 경우 (e.g., 부모와 자식 프로세스 간 통신) 사용
	- 두 개의 프로세스를 연결해 하나의 프로세스는 데이터를 쓰기만, 다른 하나는 읽기만 가능
	- 반이중 통신
	- 데이터 송/수신을 모두 하려면 두 개의 파이프를 만들어야 함
- Named PIPE
	- 전혀 모르는 상태의 프로세스들 사이의 통신일 경우 사용
	- 이 또한 반이중 통신으로 동시 송/수신을 위해서는 두 개의 파이프를 만들어야 함
- Message Queue
	- 프로세스 간 메시지 전송 시 메시지 생산자가 메시지를 큐에 추가하고, 메시지 소비자가 메시지를 검색하거나 가져와 일련의 작업을 수행
	- Queue는 메모리 공간으로, 메시지 큐에 쓸 데이터에 번호를 붙임으로써 데이터를 다루기 쉬움
- Socket
	- 통신 대상 프로세스와 일대일 연결을 통해 통신
	- 같은 도메인에서의 경우 사용 가능
- 기타 등등

> 서비스 간 IPC 매커니즘을 선택할 때 기반이 되는 다양한 상호 작용 스타일

## 2. 다양한 상호 작용 스타일 (Interaction Styles)

- 서비스에 대한 IPC 메커니즘을 선택할 때 서비스가 상호 작용하는 방식에 대해 먼저 생각하는 것이 유용
- 다양한 "클라이언트 ⇔ 서비스" 상호작용 스타일이 있음
- 두 가지 차원으로 분류
	- 일대일 (one-to-one) or 일대다 (one-to-many) 상호 작용
		- 일대일 (one-to-one): 각 클라이언트 요청은 정확히 하나의 서비스 인스턴스에 의해 처리됨
		- 일대다 (one-to-many): 각 요청은 여러 서비스 인스턴스에서 처리됨
	- 동기식 (Synchronous) or 비동기식 (Asynchronous) 상호 작용
		- 동기식 (Synchronous): 클라이언트는 서비스로부터 시기적절한 응답을 기대하며 기다리는 동안 차단할 수도 있음
		- 비동기식 (Asynchronous): 클라이언트는 응답을 기다리는 동안 차단하지 않으며 응답이 있는 경우 응답이 반드시 즉시 전송되지는 않음

> 각 차원의 상호작용의 종류 예시

### 2.1. 일대일 상호 작용의 종류

- 요청/응답 (Request/response) -> 동기식
	- 클라이언트가 서비스에 요청하고 응답을 기다림
	- 클라이언트는 응답이 적시에 도착하기를 기대
	- Thread 기반 응용 프로그램에서 요청을 만드는 Thread는 기다리는 동안 차단될 수도 있음
- 알림 (Notification) (one-way request) -> 동기식
	- 클라이언트가 서비스에 요청을 보내지만 응답이 예상되거나 전송되지 않음
- 요청/비동기 응답 (Request/async response) -> 비동기식
	- 클라이언트는 비동기적으로 응답하는 서비스에 요청을 보냄
	- 클라이언트는 기다리는 동안 차단되지 않으며 응답이 잠시 동안 도착하지 않을 수 있다는 가정 하에 설계됨

### 2.2. 일대다 상호 작용의 종류

- 게시/구독 (Publish/subscribe) -> 비동기식
	- 클라이언트가 알림 메시지를 게시하며, 이는 0개 이상의 관심 서비스에서 사용됨
- 게시/비동기 응답 (Publish/async responses) -> 비동기식
	- 클라이언트는 요청 메시지를 게시한 다음 관심 있는 서비스의 응답을 일정 시간 동안 기다림

### 2.3. 서비스 간 여러 IPC 매커니즘 사용 예시 - 택시 호출 애플리케이션

![[Screenshot 2023-10-10 at 20.55.20.png]]

- 사용자가 운행을 요청할 때 택시 호출 애플리케이션의 서비스가 상호 작용하는 방식
- 서비스는 알림, 요청/응답 및 Publish/Subscribe의 조합을 사용
	- 승객의 스마트폰은 픽업을 요청하기 위해 운행 관리 서비스에 알림을 보냄
	- 운행 관리 서비스는 요청/응답을 사용하여 승객 서비스를 호출하여 승객의 계정이 활성 상태인지 확인
	- 운행 관리 서비스는 운행을 만들고 Publish/Subscribe을 사용하여 운행 가능한 택시 드라이버를 찾는 디스패처(Dispatcher)를 비롯한 다른 서비스에 알림

## 3. 서비스 간 통신에서 발생하는 주요 문제점과 과제
### 3.1. 부분 실패

![[Screenshot 2023-10-10 at 20.54.23.png]]

- 주어진 마이크로 서비스에 대해 수십 또는 수백 개의 인스턴스가 있을 수 있음
- 인스턴스는 여러 가지 이유로 실패할 수 있음
	- 하드웨어 오류나 VM 재부팅과 같은 노드 수준 오류가 있을 수 있음
	- 인스턴스가 중단되거나 요청으로 인해 무력화되고 새로운 요청을 처리할 수 없음
	- 이러한 이벤트로 인해 네트워크 호출이 실패할 수 있음
- 넷플릭스에서 설명한 부분 실패를 처리하기 위한 전략
	- **네트워크 시간 초과(Network timeouts)** 
		- 무기한 차단하지 않고 응답을 기다릴 때 항상 시간 초과를 사용
		- 시간 초과를 사용하면 리소스가 무기한으로 묶이지 않음
	- **미해결 요청 수 제한(Limiting the number of outstanding requests)**
		- 클라이언트가 특정 서비스에 대해 가질 수 있는 미해결 요청 수에 상한선을 부과
		- 제한에 도달한 경우 추가 요청을 하는 것은 무의미할 수 있으며 이러한 시도는 즉시 실패해야 함
	- **회로 차단기 패턴(Circuit breaker pattern)**
		- 성공 및 실패한 요청 수를 추적
		- 오류율이 구성된 임계값을 초과하면 추가 시도가 즉시 실패하도록 회로 차단기를 트립
			- 많은 수의 요청이 실패하면 서비스를 사용할 수 없고 요청을 보내는 것이 무의미하다는 의미
		- 시간 초과 기간 후에 클라이언트는 다시 시도하고 성공하면 회로 차단기를 닫아야 함
	- **대체 제공(Provide fallbacks)**
		- 요청이 실패할 때 대체 로직를 수행
		- 예를 들어 캐시된 데이터 또는 빈 권장 사항 세트와 같은 기본값을 반환
	- Netflix Hystrix는 이러한 패턴과 기타 패턴을 구현하는 오픈소스 라이브러리
		- JVM을 사용하는 경우 Hystrix 사용을 반드시 고려해야 함
		- 또한 JVM이 아닌 환경에서 실행 중인 경우 동등한 라이브러리를 사용해야 함

### 3.2. 부하 분산

- 서비스 "A"가 서비스 "B"를 호출하면 요청이 서비스 "B"의 실행 중인 **인스턴스**에 도달해야 함
- Kubernetes에서 `Service` 리소스 유형은 Pod 그룹에 대해 안정적인 IP 주소를 제공
	- iptable 규칙을 사용하여 서비스의 IP 주소에 대한 네트워크 트래픽이 Pod에 전달됨
	- 기본적으로 Pod가 무작위로 선택됨
- 서비스 메시는 관찰된 대기 시간이나 기타 메트릭을 기반으로 보다 지능적인 부하 분산 알고리즘을 제공할 수 있음

### 3.3. 분산 추적

- 여러 서비스에 걸친 단일 트랜잭션이 있을 수 있음
- 이런 경우 시스템의 전반적인 성능과 상태를 모니터링하기가 어려워짐
- 모든 서비스가 로그와 메트릭을 생성하더라도 이것을 함께 연결할 방법이 없다면 사용이 제한됨

### 3.4. 서비스 버전 관리

- 팀이 새 버전의 서비스를 배포할 때 그에 종속된 다른 서비스나 외부 클라이언트가 손상되지 않도록 해야 함
- 또한 여러 버전의 서비스를 side-by-side 실행하고 특정 버전으로 요청을 라우팅하는 것이 좋음

> 그래서 어떤 상호 작용 스타일의 IPC 매커니즘이나 기술을 가지고 해당 문제를 해결해야 하나?

## 4. 메시징 기반 IPC, 비동기식 메시지 기반 통신 (Asynchronous, Message‑Based Communication) 사용

### 4.1. 통신 원리

- 메시징을 사용할 때 프로세스는 비동기적으로 메시지를 교환하여 통신
- 클라이언트는 메시지를 보내 서비스에 요청
- 서비스가 응답할 것으로 예상되면 별도의 메시지를 클라이언트에 다시 전송하여 응답
- 통신은 비동기식이므로 클라이언트는 응답 대기를 차단하지 않음
	- 대신 클라이언트는 응답이 즉시 수신되지 않는다는 가정하에 작성됨

### 4.2. 구성 요소

- 메시지는 헤더(발신자와 같은 메타데이터)와 메시지 본문으로 구성됨
- 메시지는 채널을 통해 교환됨
	- 원하는 수의 생산자가 채널에 메시지를 보낼 수 있음
- 마찬가지로, 원하는 수의 소비자가 채널에서 메시지를 받을 수 있음
- 채널에는 지점 간 및 Publish-subscribe의 두 가지 종류가 있음
- 지점 간 채널은 채널에서 읽고 있는 소비자 중 정확히 한 명에게 메시지를 전달
- 서비스는 앞에서 설명한 일대일 상호 작용 스타일에 대해 지점 간 채널을 사용
- Publish-subscribe 채널은 연결된 모든 소비자에게 각 메시지를 전달
- 서비스는 위에서 설명한 일대다 상호 작용 스타일에 대해 Publish-subscribe 채널을 사용

### 4.3. 메시징 예시 - 택시 호출 애플리케이션

![[Screenshot 2023-10-10 at 20.45.33.png]]

- 택시 호출 애플리케이션이 Publish-Subscribe 채널을 사용하는 방법
- 운행 관리 서비스(Trip)는 Publish-Subscribe 채널에 운행 생성 메시지를 작성하여 새로운 운행에 대해 Dispatcher와 같은 서비스에 알림
- Dispatcher는 운행 가능한 택시 드라이버를 찾고 게시-구독 채널에 택시 드라이버 제안 메시지를 작성하여 다른 서비스에 알림

### 4.4. 선택할 수 있는 메시징 시스템

- 다양한 프로그래밍 언어를 지원하는 언어를 선택해야 함
- 일부 메시징 시스템은 AMQP 및 STOMP와 같은 표준 프로토콜을 지원
- 메시징 시스템에는 독점적이지만 문서화된 프로토콜이 있음
- RabbitMQ, Apache Kafka, Apache ActiveMQ 및 NSQ를 포함하여 선택할 수 있는 수많은 오픈 소스 메시징 시스템이 있음
	- 모두 높은 수준에서 어떤 형태의 메시지와 채널을 지원
	- 모두 안정적이고 고성능이며 확장 가능하기 위해 노력
	- 그러나 각 브로커의 메시징 모델의 세부 사항에는 상당한 차이가 있음

### 4.5. 메시징을 사용했을 때 얻을 수 있는 장점

#### 4.5.1. 서비스에서 클라이언트 분리
- 클라이언트는 단순히 메시지를 적절한 채널로 전송하여 요청
- 클라이언트는 서비스 인스턴스를 완전히 인식하지 못함
- 서비스 인스턴스의 위치를 결정하기 위해 검색 메커니즘을 사용할 필요가 없음

#### 4.5.2. 메시지 버퍼링
- HTTP와 같은 동기식 요청/응답 프로토콜을 사용하면 교환 기간 동안 클라이언트와 서비스를 모두 사용할 수 있어야 함
- 대조적으로 메시지 브로커는 소비자가 처리할 수 있을 때까지 채널에 작성된 메시지를 대기열에 넣음
- 이는 예를 들어 주문 처리 시스템이 느리거나 사용할 수 없는 경우에도 온라인 상점이 고객의 주문을 수락할 수 있음을 의미
	- 주문 메시지는 단순히 대기열에 있음

#### 4.5.3. 유연한 클라이언트 - 서비스 상호 작용
- 메시징은 앞에서 설명한 모든 상호 작용 스타일을 지원

#### 4.5.4. 명시적 프로세스 간 통신
- RPC 기반 메커니즘은 원격 서비스 호출이 로컬 서비스 호출과 동일하게 보이도록 시도
	- 그러나 물리 법칙과 부분적 실패 가능성 때문에 실제로는 상당히 다름
- 메시징은 이러한 차이를 매우 명확하게 하여 개발자가 잘못된 보안 감각에 속아 넘어가지 않도록 함

### 4.6. 메시징을 사용했을 때 생기는 단점
#### 4.6.1. 추가적인 운영 복잡성
- 메시징 시스템은 설치, 구성 및 운영되어야 하는 또 다른 시스템 구성 요소
- 메시지 브로커는 고가용성이어야 하며 그렇지 않으면 시스템 안정성이 영향을 받음

#### 4.6.2. 요청/응답 기반 상호 작용 구현의 복잡성
- 요청/응답 스타일 상호 작용을 구현하려면 약간의 작업이 필요
	- 각 요청 메시지에는 응답 채널 식별자와 상관 식별자가 포함되어야 함
	- 서비스는 상관 ID를 포함하는 응답 메시지를 응답 채널에 씀
	- 클라이언트는 상관 ID를 사용하여 응답을 요청과 일치시킴
- 요청/응답을 직접 지원하는 IPC 메커니즘을 사용하는 것이 더 쉬운 경우가 많음

## 5. 동기식, 요청/응답 IPC (Synchronous, Request/Response IPC) 사용

- 동기식 요청/응답 기반 IPC 메커니즘을 사용할 때 클라이언트는 서비스에 요청을 보냄
- 서비스는 요청을 처리하고 응답을 다시 보냅니다. 많은 클라이언트에서 요청을 만드는 스레드는 응답을 기다리는 동안 차단됨
- 다른 클라이언트는 Futures 또는 Rx Observables에 의해 캡슐화될 수 있는 비동기 이벤트 구동 클라이언트 코드를 사용할 수 있음
- 그러나 메시징을 사용할 때와 달리 클라이언트는 응답이 적시에 도착한다고 가정함
- 선택할 수 있는 프로토콜이 많이 있음
- 널리 사용되는 두 가지 프로토콜은 REST와 Thrift

### 5.1. REST

- 오늘날 RESTful 스타일로 API를 개발하는 것이 유행
- REST는 (거의 항상) HTTP를 사용하는 IPC 메커니즘
- REST의 핵심 개념은 일반적으로 고객 또는 제품과 같은 비즈니스 개체 또는 비즈니스 개체 컬렉션을 나타내는 리소스
- REST는 URL을 사용하여 참조되는 리소스를 조작하기 위해 HTTP 동사를 사용
	- 예를 들어, GET 요청은 XML 문서 또는 JSON 객체의 형태일 수 있는 리소스의 표현을 반환
	- POST 요청은 새 리소스를 생성하고 PUT 요청은 리소스를 업데이트
- REST의 창시자인 Roy Fielding의 말을 인용하자면:

> “REST는 전체적으로 적용될 때 구성 요소 상호 작용의 확장성, 인터페이스의 일반성, 구성 요소의 독립적 배포 및 중간 구성 요소를 강조하여 상호 작용 대기 시간을 줄이고 보안을 강화하며 레거시 시스템을 캡슐화하는 일련의 아키텍처 제약 조건을 제공합니다.”

#### 5.1.1. REST 예시 - 택시 호출 애플리케이션

![[Screenshot 2023-10-10 at 20.50.51.png]]

- 택시 호출 애플리케이션이 REST를 사용할 수 있는 방법
- 승객의 스마트폰은 운행 관리 서비스의 /trips 리소스에 POST 요청을 하여 운행을 요청
- 이 서비스는 승객 정보에 대한 GET 요청을 승객 관리 서비스로 전송하여 요청을 처리
- 승객이 운행을 만들 수 있는 권한이 있는지 확인한 후 운행 관리 서비스는 운행을 만들고 스마트폰에 201 응답을 반환

#### 5.1.2. HTTP 기반 프로토콜의 장점
- HTTP는 간단하고 친숙
- Postman과 같은 확장을 사용하여 브라우저 내에서 또는 curl을 사용하여 명령줄에서 HTTP API를 테스트할 수 있음 (JSON 또는 기타 텍스트 형식이 사용된다고 가정)
- 요청/응답 방식의 통신을 직접 지원
- 방화벽 친화적
- 시스템 아키텍처를 단순화하는 중간 브로커가 필요하지 않음

#### 5.1.3. HTTP 기반 프로토콜의 단점
- 요청/응답 방식의 상호 작용만 직접 지원
	- 알림에 HTTP를 사용할 수 있지만 서버는 항상 HTTP 응답을 보내야 함
- 클라이언트와 서비스는 메시지를 버퍼링하는 중개자 없이 직접 통신하기 때문에 교환 기간 동안 둘 다 실행되어야 함
- 클라이언트는 각 서비스 인스턴스의 위치(즉, URL)를 알아야 함
	- 클라이언트는 서비스 검색 메커니즘을 사용하여 서비스 인스턴스를 찾아야 함

### 5.2. Thrift

- Apache Thrift는 REST에 대한 흥미로운 대안
- 언어 간 RPC 클라이언트 및 서버를 작성하기 위한 프레임워크
- Thrift는 API 정의를 위한 C 스타일 IDL을 제공
- Thrift 컴파일러를 사용하여 클라이언트 측 스텁과 서버 측 스켈레톤을 생성
- 컴파일러는 C++, Java, Python, PHP, Ruby, Erlang 및 Node.js를 비롯한 다양한 언어에 대한 코드를 생성

#### 5.2.1. 특징
- Thrift 인터페이스는 하나 이상의 서비스로 구성 서비스 정의는 Java 인터페이스와 유사
- Thrift 메서드는 (무효일 수 있음) 값을 반환하거나 단방향으로 정의할 수 있음
	- 값을 반환하는 메서드는 상호 작용의 요청/응답 스타일을 구현
- 클라이언트는 응답을 기다리며 예외를 throw할 수 있음
- 단방향 방법은 알림 스타일의 상호 작용에 해당
	- 서버는 응답을 보내지 않음
- Thrift는 JSON, 바이너리 및 컴팩트 바이너리와 같은 다양한 메시지 형식을 지원
	- 바이너리는 디코딩이 더 빠르기 때문에 JSON보다 더 효율적
- Thrift는 또한 원시 TCP 및 HTTP를 포함한 전송 프로토콜을 선택할 수 있도록 함
	- 원시 TCP는 HTTP보다 더 효율적일 수 있음
	- 그러나 HTTP는 방화벽, 브라우저 및 인간 친화적

## 6. 메시지 형식 (Message Formats)

- 메시징 시스템 또는 REST를 사용하는 경우 메시지 형식을 선택하게 됨
- Thrift와 같은 IPC 메커니즘은 적은 수의 메시지 형식만 지원
- 두 경우 모두 언어 간 메시지 형식을 사용하는 것이 중요
	- 현재 단일 언어로 마이크로서비스를 작성하고 있더라도 미래에는 다른 언어를 사용할 가능성이 높음

### 6.2. 두 가지 주요 유형

#### 6.2.1. 텍스트

- 텍스트 기반 형식의 예로는 JSON 및 XML이 있음
- 이러한 형식의 장점은 사람이 읽을 수 있을 뿐만 아니라 자체적으로 설명할 수 있다는 것
	- JSON에서 객체의 속성은 이름-값 쌍의 컬렉션으로 표현됨
	- 마찬가지로 XML에서 속성은 명명된 요소와 값으로 표현됨
- 이를 통해 메시지 소비자는 관심 있는 값을 선택하고 나머지는 무시할 수 있음
- 결과적으로 메시지 형식에 대한 사소한 변경은 이전 버전과 쉽게 호환될 수 있음
- 텍스트 기반 메시지 형식 사용의 단점
	- 메시지, 특히 XML이 장황한 경향이 있다는 것
		- 메시지가 자체 설명적이기 때문에 모든 메시지에는 속성 값과 함께 속성 이름이 포함됨
	- 텍스트 구문 분석의 오버헤드

#### 6.2.2. 바이너리

- Thrift RPC를 사용하는 경우 바이너리 Thrift를 사용할 수 있음
- 메시지 형식을 선택하는 경우 많이 사용되는 옵션에는 프로토콜 버퍼 및 Apache Avro가 있음
- 두 형식 모두 메시지 구조를 정의하기 위한 형식화된 IDL(인터페이스 정의 언어)을 제공

## 7. 서비스 메시 사용

- 서비스 메시는 서비스 간 통신을 처리하는 소프트웨어 계층
- 서비스 메시는 서비스 간 통신에 있어 많은 문제를 해결하고 이러한 문제에 대한 책임을 마이크로 서비스 자체에서 공유 레이어로 이동하도록 설계됨
- 서비스 메시는 클러스터의 마이크로 서비스 사이에 네트워크 통신을 가로채는 프록시로 작동
- 현재 서비스 메시 개념은 서버리스 아키텍처가 아닌 컨테이너 오케스트레이터에 주로 적용됨

### 7.1. Kubernetes에서 서비스 메시에 대한 주요 옵션 - Linkerd, Istio
#### 7.1.1. 공통되는 몇 가지 기능
- 관찰된 대기 시간이나 미해결 요청 수에 기반한 세션 수준의 부하 분산
	- 이를 통해 Kubernetes에 제공되는 계층 4 부하 분산보다 성능이 향상될 수 있음
- URL 경로, Host 헤더, API 버전 또는 기타 애플리케이션 수준 규칙에 기반한 계층 7 라우팅
- 실패한 요청 다시 시도
	- 서비스 메시는 HTTP 오류 코드를 이해하고 실패한 요청을 자동으로 다시 시도할 수 있음
	- 최대 대기 시간을 제한하기 위해 시간 초과 기간과 함께 최대 다시 시도 횟수를 구성할 수 있음
- 회로 차단
	- 인스턴스가 일관적으로 요청에 실패하면 서비스 메시는 해당 요청을 일시적으로 사용할 수 없게 표시
	- 백오프 기간 후에 인스턴스를 다시 시도
	- 회로 차단기는 다양한 기준(예: 연속 실패 횟수)을 기반으로 구성할 수 있음 
- 서비스 메시는 서비스 간 호출에 대한 메트릭(예: 요청 볼륨, 대기 시간, 오류 및 성공률 및 응답 크기)을 캡처
	- 또한 서비스 메시는 요청의 각 홉에 대한 상관 관계 정보를 추가하여 분산 추적을 가능하게 함
- 서비스 간 호출에 대한 상호 TLS 인증

### 7.2. 서비스 메시의 장점

- 서비스 메시가 없으면 이 문서의 앞부분에 언급된 각각의 도전 과제를 고려해야 함
- 다시 시도, 회로 차단기 및 분산 추적과 같은 문제는 서비스 메시가 없어도 해결할 수 있지만 서비스 메시를 사용하면 이러한 문제를 개별 서비스에서 전용 레이어로 이동시킴

### 7.3. 서비스 메시의 단점

- 서비스 메시를 배포하면 클러스터 설정과 구성이 더 복잡해짐
- 요청이 서비스 메시 프록시를 통해 라우팅되기 때문에 그리고 추가 서비스가 클러스터의 모든 노드에서 실행되기 때문에 성능에 영향을 미칠 수 있음
- 서비스 메시를 프로덕션에 배포하기 전에 철저한 성능 및 부하 테스트를 수행해야 함
